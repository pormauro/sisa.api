Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: .env
Content:
JWT_SECRET=mi_clave_secreta

DB_HOST=localhost
DB_NAME=u650890769_sistema
DB_USER=u650890769_pormauro
DB_PASS=2M~w:F]tl

LOCK_TIME_MINUTES=15
MAX_FAILED_ATTEMPTS=3

# ConfiguraciÃ³n SMTP para enviar emails
SMTP_HOST=smtp.hostinger.com
SMTP_USER=no-reply@sistema.depros.com.ar
SMTP_PASS=oH*r&+y9K
SMTP_SECURE=ssl
SMTP_PORT=465
SMTP_FROM=no-reply@sistema.depros.com.ar
SMTP_FROM_NAME="Sistema de GestiÃ³n DEPROS"

# Zona horaria del sistema
TIME_ZONE=America/Argentina/Buenos_Aires

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: .htaccess
Content:
# Activar reescritura de URLs
<IfModule mod_rewrite.c>
    RewriteEngine On

    # Proteger el archivo .env para que no se pueda acceder directamente
    <FilesMatch "^\.env">
        Order allow,deny
        Deny from all
    </FilesMatch>

    # Si el archivo o directorio solicitado no existe, redirigir a index.php
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^.*$ index.php [QSA,L]

    php_flag display_errors on
    php_value error_reporting -1
</IfModule>

<IfModule mod_headers.c>
    # Cabeceras de seguridad bÃ¡sicas
    Header always set X-Frame-Options "SAMEORIGIN"
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-XSS-Protection "1; mode=block"
</IfModule>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: activate.php
Content:
<?php
// public_html/activate.php

require_once __DIR__ . '/vendor/autoload.php';

use Dotenv\Dotenv;
use App\Models\User;

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

if (!isset($_GET['token'])) {
    die("Token no proporcionado.");
}

$token = $_GET['token'];
$user = new User();
$result = $user->activateUser($token);

if ($result) {
    echo "Cuenta activada exitosamente. Ya puedes iniciar sesiÃ³n.";
} else {
    echo "El token es invÃ¡lido o la cuenta ya estÃ¡ activada.";
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: composer.json
Content:
{
    "name": "pormauro/sistema",
    "description": "Sistema de gestiÃ³n de empresas de tecnologÃ­a",
    "require": {
        "firebase/php-jwt": "^6.11",
        "vlucas/phpdotenv": "^5.6",
        "slim/slim":"^4.0" ,
        "phpmailer/phpmailer": "^6.8",
        "slim/psr7": "^1.7"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "authors": [
        {
            "name": "pormauro"
        }
    ]
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: composer.lock
Content:
{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "4e4096b98c73c8c3be7fefb0514647f4",
    "packages": [
        {
            "name": "fig/http-message-util",
            "version": "1.1.5",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message-util.git",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message-util/zipball/9d94dc0154230ac39e5bf89398b324a86f63f765",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765",
                "shasum": ""
            },
            "require": {
                "php": "^5.3 || ^7.0 || ^8.0"
            },
            "suggest": {
                "psr/http-message": "The package containing the PSR-7 interfaces"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Fig\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Utility classes and constants for use with PSR-7 (psr/http-message)",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-message-util/issues",
                "source": "https://github.com/php-fig/http-message-util/tree/1.1.5"
            },
            "time": "2020-11-24T22:02:12+00:00"
        },
        {
            "name": "firebase/php-jwt",
            "version": "v6.11.0",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "8f718f4dfc9c5d5f0c994cdfd103921b43592712"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/8f718f4dfc9c5d5f0c994cdfd103921b43592712",
                "reference": "8f718f4dfc9c5d5f0c994cdfd103921b43592712",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.11.0"
            },
            "time": "2025-01-23T05:11:06+00:00"
        },
        {
            "name": "graham-campbell/result-type",
            "version": "v1.1.3",
            "source": {
                "type": "git",
                "url": "https://github.com/GrahamCampbell/Result-Type.git",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/GrahamCampbell/Result-Type/zipball/3ba905c11371512af9d9bdd27d99b782216b6945",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "GrahamCampbell\\ResultType\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "An Implementation Of The Result Type",
            "keywords": [
                "Graham Campbell",
                "GrahamCampbell",
                "Result Type",
                "Result-Type",
                "result"
            ],
            "support": {
                "issues": "https://github.com/GrahamCampbell/Result-Type/issues",
                "source": "https://github.com/GrahamCampbell/Result-Type/tree/v1.1.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/graham-campbell/result-type",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:45:45+00:00"
        },
        {
            "name": "nikic/fast-route",
            "version": "v1.3.0",
            "source": {
                "type": "git",
                "url": "https://github.com/nikic/FastRoute.git",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/nikic/FastRoute/zipball/181d480e08d9476e61381e04a71b34dc0432e812",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812",
                "shasum": ""
            },
            "require": {
                "php": ">=5.4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.8.35|~5.7"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/functions.php"
                ],
                "psr-4": {
                    "FastRoute\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Nikita Popov",
                    "email": "nikic@php.net"
                }
            ],
            "description": "Fast request router for PHP",
            "keywords": [
                "router",
                "routing"
            ],
            "support": {
                "issues": "https://github.com/nikic/FastRoute/issues",
                "source": "https://github.com/nikic/FastRoute/tree/master"
            },
            "time": "2018-02-13T20:26:39+00:00"
        },
        {
            "name": "phpmailer/phpmailer",
            "version": "v6.9.3",
            "source": {
                "type": "git",
                "url": "https://github.com/PHPMailer/PHPMailer.git",
                "reference": "2f5c94fe7493efc213f643c23b1b1c249d40f47e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/PHPMailer/PHPMailer/zipball/2f5c94fe7493efc213f643c23b1b1c249d40f47e",
                "reference": "2f5c94fe7493efc213f643c23b1b1c249d40f47e",
                "shasum": ""
            },
            "require": {
                "ext-ctype": "*",
                "ext-filter": "*",
                "ext-hash": "*",
                "php": ">=5.5.0"
            },
            "require-dev": {
                "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
                "doctrine/annotations": "^1.2.6 || ^1.13.3",
                "php-parallel-lint/php-console-highlighter": "^1.0.0",
                "php-parallel-lint/php-parallel-lint": "^1.3.2",
                "phpcompatibility/php-compatibility": "^9.3.5",
                "roave/security-advisories": "dev-latest",
                "squizlabs/php_codesniffer": "^3.7.2",
                "yoast/phpunit-polyfills": "^1.0.4"
            },
            "suggest": {
                "decomplexity/SendOauth2": "Adapter for using XOAUTH2 authentication",
                "ext-mbstring": "Needed to send email in multibyte encoding charset or decode encoded addresses",
                "ext-openssl": "Needed for secure SMTP sending and DKIM signing",
                "greew/oauth2-azure-provider": "Needed for Microsoft Azure XOAUTH2 authentication",
                "hayageek/oauth2-yahoo": "Needed for Yahoo XOAUTH2 authentication",
                "league/oauth2-google": "Needed for Google XOAUTH2 authentication",
                "psr/log": "For optional PSR-3 debug logging",
                "symfony/polyfill-mbstring": "To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)",
                "thenetworg/oauth2-azure": "Needed for Microsoft XOAUTH2 authentication"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "PHPMailer\\PHPMailer\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "LGPL-2.1-only"
            ],
            "authors": [
                {
                    "name": "Marcus Bointon",
                    "email": "phpmailer@synchromedia.co.uk"
                },
                {
                    "name": "Jim Jagielski",
                    "email": "jimjag@gmail.com"
                },
                {
                    "name": "Andy Prevost",
                    "email": "codeworxtech@users.sourceforge.net"
                },
                {
                    "name": "Brent R. Matzelle"
                }
            ],
            "description": "PHPMailer is a full-featured email creation and transfer class for PHP",
            "support": {
                "issues": "https://github.com/PHPMailer/PHPMailer/issues",
                "source": "https://github.com/PHPMailer/PHPMailer/tree/v6.9.3"
            },
            "funding": [
                {
                    "url": "https://github.com/Synchro",
                    "type": "github"
                }
            ],
            "time": "2024-11-24T18:04:13+00:00"
        },
        {
            "name": "phpoption/phpoption",
            "version": "1.9.3",
            "source": {
                "type": "git",
                "url": "https://github.com/schmittjoh/php-option.git",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/schmittjoh/php-option/zipball/e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "1.9-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "PhpOption\\": "src/PhpOption/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "Apache-2.0"
            ],
            "authors": [
                {
                    "name": "Johannes M. Schmitt",
                    "email": "schmittjoh@gmail.com",
                    "homepage": "https://github.com/schmittjoh"
                },
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "Option Type for PHP",
            "keywords": [
                "language",
                "option",
                "php",
                "type"
            ],
            "support": {
                "issues": "https://github.com/schmittjoh/php-option/issues",
                "source": "https://github.com/schmittjoh/php-option/tree/1.9.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/phpoption/phpoption",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:41:07+00:00"
        },
        {
            "name": "psr/container",
            "version": "2.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/container.git",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/container/zipball/c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "shasum": ""
            },
            "require": {
                "php": ">=7.4.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Container\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common Container Interface (PHP FIG PSR-11)",
            "homepage": "https://github.com/php-fig/container",
            "keywords": [
                "PSR-11",
                "container",
                "container-interface",
                "container-interop",
                "psr"
            ],
            "support": {
                "issues": "https://github.com/php-fig/container/issues",
                "source": "https://github.com/php-fig/container/tree/2.0.2"
            },
            "time": "2021-11-05T16:47:00+00:00"
        },
        {
            "name": "psr/http-factory",
            "version": "1.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-factory.git",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-factory/zipball/2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "PSR-17: Common interfaces for PSR-7 HTTP message factories",
            "keywords": [
                "factory",
                "http",
                "message",
                "psr",
                "psr-17",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-factory"
            },
            "time": "2024-04-15T12:06:14+00:00"
        },
        {
            "name": "psr/http-message",
            "version": "2.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message.git",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message/zipball/402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "shasum": ""
            },
            "require": {
                "php": "^7.2 || ^8.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP messages",
            "homepage": "https://github.com/php-fig/http-message",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-message/tree/2.0"
            },
            "time": "2023-04-04T09:54:51+00:00"
        },
        {
            "name": "psr/http-server-handler",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-handler.git",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-handler/zipball/84c4fb66179be4caaf8e97bd239203245302e7d4",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side request handler",
            "keywords": [
                "handler",
                "http",
                "http-interop",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response",
                "server"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-server-handler/tree/1.0.2"
            },
            "time": "2023-04-10T20:06:20+00:00"
        },
        {
            "name": "psr/http-server-middleware",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-middleware.git",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-middleware/zipball/c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0",
                "psr/http-server-handler": "^1.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side middleware",
            "keywords": [
                "http",
                "http-interop",
                "middleware",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-server-middleware/issues",
                "source": "https://github.com/php-fig/http-server-middleware/tree/1.0.2"
            },
            "time": "2023-04-11T06:14:47+00:00"
        },
        {
            "name": "psr/log",
            "version": "3.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/log.git",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/log/zipball/f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "shasum": ""
            },
            "require": {
                "php": ">=8.0.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Log\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for logging libraries",
            "homepage": "https://github.com/php-fig/log",
            "keywords": [
                "log",
                "psr",
                "psr-3"
            ],
            "support": {
                "source": "https://github.com/php-fig/log/tree/3.0.2"
            },
            "time": "2024-09-11T13:17:53+00:00"
        },
        {
            "name": "ralouphie/getallheaders",
            "version": "3.0.3",
            "source": {
                "type": "git",
                "url": "https://github.com/ralouphie/getallheaders.git",
                "reference": "120b605dfeb996808c31b6477290a714d356e822"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/ralouphie/getallheaders/zipball/120b605dfeb996808c31b6477290a714d356e822",
                "reference": "120b605dfeb996808c31b6477290a714d356e822",
                "shasum": ""
            },
            "require": {
                "php": ">=5.6"
            },
            "require-dev": {
                "php-coveralls/php-coveralls": "^2.1",
                "phpunit/phpunit": "^5 || ^6.5"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/getallheaders.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ralph Khattar",
                    "email": "ralph.khattar@gmail.com"
                }
            ],
            "description": "A polyfill for getallheaders.",
            "support": {
                "issues": "https://github.com/ralouphie/getallheaders/issues",
                "source": "https://github.com/ralouphie/getallheaders/tree/develop"
            },
            "time": "2019-03-08T08:55:37+00:00"
        },
        {
            "name": "slim/psr7",
            "version": "1.7.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim-Psr7.git",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim-Psr7/zipball/753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "shasum": ""
            },
            "require": {
                "fig/http-message-util": "^1.1.5",
                "php": "^8.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.0 || ^2.0",
                "ralouphie/getallheaders": "^3.0",
                "symfony/polyfill-php80": "^1.29"
            },
            "provide": {
                "psr/http-factory-implementation": "^1.0",
                "psr/http-message-implementation": "^1.0 || ^2.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-json": "*",
                "http-interop/http-factory-tests": "^1.1.0",
                "php-http/psr7-integration-tests": "1.3.0",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.2",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "squizlabs/php_codesniffer": "^3.10"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\Psr7\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "http://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                }
            ],
            "description": "Strict PSR-7 implementation",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "http",
                "psr-7",
                "psr7"
            ],
            "support": {
                "issues": "https://github.com/slimphp/Slim-Psr7/issues",
                "source": "https://github.com/slimphp/Slim-Psr7/tree/1.7.0"
            },
            "time": "2024-06-08T14:48:17+00:00"
        },
        {
            "name": "slim/slim",
            "version": "4.14.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim.git",
                "reference": "5943393b88716eb9e82c4161caa956af63423913"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim/zipball/5943393b88716eb9e82c4161caa956af63423913",
                "reference": "5943393b88716eb9e82c4161caa956af63423913",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "nikic/fast-route": "^1.3",
                "php": "^7.4 || ^8.0",
                "psr/container": "^1.0 || ^2.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.1 || ^2.0",
                "psr/http-server-handler": "^1.0",
                "psr/http-server-middleware": "^1.0",
                "psr/log": "^1.1 || ^2.0 || ^3.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-simplexml": "*",
                "guzzlehttp/psr7": "^2.6",
                "httpsoft/http-message": "^1.1",
                "httpsoft/http-server-request": "^1.1",
                "laminas/laminas-diactoros": "^2.17 || ^3",
                "nyholm/psr7": "^1.8",
                "nyholm/psr7-server": "^1.1",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.1",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "slim/http": "^1.3",
                "slim/psr7": "^1.6",
                "squizlabs/php_codesniffer": "^3.10",
                "vimeo/psalm": "^5.24"
            },
            "suggest": {
                "ext-simplexml": "Needed to support XML format in BodyParsingMiddleware",
                "ext-xml": "Needed to support XML format in BodyParsingMiddleware",
                "php-di/php-di": "PHP-DI is the recommended container library to be used with Slim",
                "slim/psr7": "Slim PSR-7 implementation. See https://www.slimframework.com/docs/v4/start/installation.html for more information."
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\": "Slim"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "https://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                },
                {
                    "name": "Gabriel Manricks",
                    "email": "gmanricks@me.com",
                    "homepage": "http://gabrielmanricks.com"
                }
            ],
            "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "api",
                "framework",
                "micro",
                "router"
            ],
            "support": {
                "docs": "https://www.slimframework.com/docs/v4/",
                "forum": "https://discourse.slimframework.com/",
                "irc": "irc://irc.freenode.net:6667/slimphp",
                "issues": "https://github.com/slimphp/Slim/issues",
                "rss": "https://www.slimframework.com/blog/feed.rss",
                "slack": "https://slimphp.slack.com/",
                "source": "https://github.com/slimphp/Slim",
                "wiki": "https://github.com/slimphp/Slim/wiki"
            },
            "funding": [
                {
                    "url": "https://opencollective.com/slimphp",
                    "type": "open_collective"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/slim/slim",
                    "type": "tidelift"
                }
            ],
            "time": "2024-06-13T08:54:48+00:00"
        },
        {
            "name": "symfony/polyfill-ctype",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-ctype.git",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-ctype/zipball/a3cc8b044a6ea513310cbd48ef7333b384945638",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-ctype": "*"
            },
            "suggest": {
                "ext-ctype": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Ctype\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Gert de Pagter",
                    "email": "BackEndTea@gmail.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for ctype functions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "ctype",
                "polyfill",
                "portable"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-ctype/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-mbstring",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-mbstring.git",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-mbstring": "*"
            },
            "suggest": {
                "ext-mbstring": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Mbstring\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for the Mbstring extension",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "mbstring",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-mbstring/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-php80",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-php80.git",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-php80/zipball/60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Php80\\": ""
                },
                "classmap": [
                    "Resources/stubs"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ion Bazan",
                    "email": "ion.bazan@gmail.com"
                },
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill backporting some PHP 8.0+ features to lower PHP versions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-php80/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "vlucas/phpdotenv",
            "version": "v5.6.1",
            "source": {
                "type": "git",
                "url": "https://github.com/vlucas/phpdotenv.git",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/vlucas/phpdotenv/zipball/a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "shasum": ""
            },
            "require": {
                "ext-pcre": "*",
                "graham-campbell/result-type": "^1.1.3",
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3",
                "symfony/polyfill-ctype": "^1.24",
                "symfony/polyfill-mbstring": "^1.24",
                "symfony/polyfill-php80": "^1.24"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "ext-filter": "*",
                "phpunit/phpunit": "^8.5.34 || ^9.6.13 || ^10.4.2"
            },
            "suggest": {
                "ext-filter": "Required to use the boolean validator."
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "5.6-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Dotenv\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                },
                {
                    "name": "Vance Lucas",
                    "email": "vance@vancelucas.com",
                    "homepage": "https://github.com/vlucas"
                }
            ],
            "description": "Loads environment variables from `.env` to `getenv()`, `$_ENV` and `$_SERVER` automagically.",
            "keywords": [
                "dotenv",
                "env",
                "environment"
            ],
            "support": {
                "issues": "https://github.com/vlucas/phpdotenv/issues",
                "source": "https://github.com/vlucas/phpdotenv/tree/v5.6.1"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/vlucas/phpdotenv",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:52:34+00:00"
        }
    ],
    "packages-dev": [],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": [],
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": [],
    "platform-dev": [],
    "plugin-api-version": "2.6.0"
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: debug.php
Content:
<?php
// debug.php - Endpoint de depuraciÃ³n
// Este archivo mostrarÃ¡ informaciÃ³n de la peticiÃ³n que llega al servidor.

header('Content-Type: application/json; charset=utf-8');

// Recopilar informaciÃ³n de la solicitud
$method = $_SERVER['REQUEST_METHOD'] ?? '';
$uri = $_SERVER['REQUEST_URI'] ?? '';
$queryParams = $_GET;
$postParams = $_POST;
$rawInput = file_get_contents('php://input');
$headers = function_exists('getallheaders') ? getallheaders() : [];

// Armar la respuesta de depuraciÃ³n
$response = [
    'method'        => $method,
    'uri'           => $uri,
    'query_params'  => $queryParams,
    'post_params'   => $postParams,
    'raw_input'     => $rawInput,
    'headers'       => $headers,
];

// Imprimir la respuesta en formato JSON
echo json_encode($response, JSON_PRETTY_PRINT);
exit;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: download_test.html
Content:
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Descargar Archivo - Sistema DEPROS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
        }
        input, button {
            padding: 8px;
            margin-bottom: 16px;
            width: 100%;
            max-width: 500px;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

<h2>Descargar Archivo</h2>

<label for="fileId">ID del Archivo:</label>
<input type="text" id="fileId" placeholder="Ej: 123">

<label for="token">Token JWT (Bearer):</label>
<input type="text" id="token" placeholder="Pega tu token aquÃ­">

<button onclick="fetchFile()">Descargar Archivo</button>

<h3>InformaciÃ³n del Archivo</h3>
<pre id="fileInfo">Esperando informaciÃ³n...</pre>

<script>
async function fetchFile() {
    const fileId = document.getElementById('fileId').value;
    const token = document.getElementById('token').value;
    const fileInfoEl = document.getElementById('fileInfo');

    fileInfoEl.textContent = 'Descargando archivo...';

    if (!fileId || !token) {
        alert('Por favor ingresa el ID del archivo y el token.');
        return;
    }

    const url = `https://sistema.depros.com.ar/get_file?file_id=${encodeURIComponent(fileId)}`;

    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            fileInfoEl.textContent = 'Error: ' + errorText;
            return;
        }

        const contentDisposition = response.headers.get('Content-Disposition');
        const fileName = contentDisposition ? contentDisposition.split('filename="')[1].split('"')[0] : 'archivo_desconocido';
        const blob = await response.blob();

        const fileUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = fileUrl;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        fileInfoEl.textContent = `Archivo "${fileName}" descargado correctamente.`;

    } catch (error) {
        fileInfoEl.textContent = 'Error al conectar: ' + error.message;
    }
}
</script>

</body>
</html>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: index.php
Content:
<?php

// public/index.php

require_once __DIR__ . '/vendor/autoload.php';

use Dotenv\Dotenv;
use Slim\Factory\AppFactory;

// Cargar variables de entorno
$dotenv = Dotenv::createMutable(__DIR__); // Busca .env
$dotenv->load();

// Crear la instancia de la aplicaciÃ³n Slim
$app = AppFactory::create();

// Habilitar el middleware de errores (para desarrollo)
$app->addErrorMiddleware(true, true, true);

// >>> AÃ‘ADIMOS este middleware de logging <<<
$app->add(new \App\Middleware\ActivityLogMiddleware());

// Establecer cabeceras para la respuesta JSON (opcional, si quieres global)
header('Content-Type: application/json; charset=utf-8');

// Incluir rutas
require_once __DIR__ . '/src/Routes/api.php';

// Ejecutar la app
$app->run();

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: install.php
Content:
    <?php
/**
 * install.php
 *
 * Script to install or update the database.
 *
 * - If the "users" table does not exist, it creates it with the complete structure.
 *   It is assumed that if it exists, it already has the required structure.
 *
 * - Creates/verifies the following tables:
 *      users, files, activity_log,
 *      user_profile, user_profile_history, user_configurations, user_configurations_history,
 *      clients, clients_history, products_services, folders, jobs, sales, expenses,
 *      appointments, notifications, cash_boxes, accounting_closings.
 *
 * For historical data (clients_history, user_profile_history, etc.) the foreign key constraints
 * referencing users (or clients, etc.) have been removed (or replaced by indexes)
 * so that, upon deletion of the user, the historical data is preserved.
 *
 * Only in user_profile and user_configurations we keep the FK to users with ON DELETE CASCADE.
 *
 * Images and documents are referenced via the "files" table.
 */

require_once __DIR__ . '/vendor/autoload.php';
use Dotenv\Dotenv;

// Load environment variables from .env
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

// Database credentials
$db_host = $_ENV['DB_HOST'] ?? 'localhost';
$db_name = $_ENV['DB_NAME'] ?? 'my_db';
$db_user = $_ENV['DB_USER'] ?? 'root';
$db_pass = $_ENV['DB_PASS'] ?? '';

try {
    $dsn = "mysql:host={$db_host};dbname={$db_name};charset=utf8mb4";
    $pdo = new PDO($dsn, $db_user, $db_pass);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // Helper function to execute SQL in a standardized way
    function executeSQL(PDO $pdo, string $sql, string $successMessage): void {
        try {
            $pdo->exec($sql);
            echo $successMessage . "<br/>";
        } catch (PDOException $e) {
            echo "Error: " . $e->getMessage() . "<br/>";
        }
    }

    // -------------------------------
    // 1. Table: users
    // -------------------------------
    $stmt = $pdo->query("SHOW TABLES LIKE 'users'");
    $tableExists = $stmt->fetch();
    if (!$tableExists) {
        $createSql = "CREATE TABLE users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            username VARCHAR(255) NOT NULL UNIQUE,
            email VARCHAR(255) NOT NULL UNIQUE,
            password VARCHAR(255) NOT NULL,
            api_token VARCHAR(255) DEFAULT NULL,
            failed_attempts INT NOT NULL DEFAULT 0,
            locked_until DATETIME DEFAULT NULL,
            password_reset_token VARCHAR(255) DEFAULT NULL,
            password_reset_expires DATETIME DEFAULT NULL,
            activation_token VARCHAR(255) DEFAULT NULL,
            activated TINYINT(1) NOT NULL DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
        executeSQL($pdo, $createSql, "Table 'users' created successfully.");
    } else {
        echo "Table 'users' already exists. Verification completed.<br/>";
    }

    // -------------------------------
    // 20. Table: permissions
    // -------------------------------
    $createPermissionsSql = "CREATE TABLE IF NOT EXISTS permissions (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT DEFAULT NULL,
        sector VARCHAR(100) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (sector)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createPermissionsSql, "Table 'permissions' created/verified.");
    
    // -------------------------------
    // 21. Table: permissions_history
    // -------------------------------
    $createPermissionsHistorySql = "CREATE TABLE IF NOT EXISTS permissions_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        permission_id INT NOT NULL,
        user_id INT DEFAULT NULL,
        sector VARCHAR(100) NOT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (permission_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createPermissionsHistorySql, "Table 'permissions_history' created/verified.");
    
    
    // -------------------------------
    // 2. Table: files
    // -------------------------------
    // En vez de FK a users, solo Ã­ndice para conservar la info histÃ³rica.
    $createFilesSql = "CREATE TABLE IF NOT EXISTS files (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        original_name VARCHAR(255) NOT NULL,
        file_type VARCHAR(100) NOT NULL,
        file_size INT NOT NULL,
        file_data LONGBLOB NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createFilesSql, "Table 'files' created/verified.");

    // -------------------------------
    // 3. Table: activity_log
    // -------------------------------
    // Ya se usa INDEX en lugar de FK para user_id.
    $createActivityLogSql = "CREATE TABLE IF NOT EXISTS activity_log (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NULL,
        route VARCHAR(255) NOT NULL,
        method VARCHAR(10) NOT NULL,
        ip_address VARCHAR(45) NOT NULL,
        user_agent TEXT,
        action_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        status_code INT NOT NULL,
        message TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (route),
        INDEX (ip_address)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createActivityLogSql, "Table 'activity_log' created/verified.");

    // ===================================================
    // Complementary tables (without is_deleted and edit_id)
    // ===================================================

    // 4. Table: user_profile
    // Se mantiene FK a users para que al eliminar el usuario se elimine el perfil.
    $sql = "CREATE TABLE IF NOT EXISTS user_profile (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        full_name VARCHAR(255) DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        cuit VARCHAR(20) DEFAULT NULL,
        profile_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (profile_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_profile' created/verified.");

    // 5. Table: user_profile_history
    // Se eliminan las FK y se dejan Ã­ndices para conservar la informaciÃ³n histÃ³rica.
    $sql = "CREATE TABLE IF NOT EXISTS user_profile_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        profile_id INT NOT NULL,
        user_id INT NOT NULL,
        full_name VARCHAR(255) NOT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        cuit VARCHAR(20) DEFAULT NULL,
        profile_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (profile_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_profile_history' created/verified.");

    // 6. Table: user_configurations
    // Se mantiene FK a users para que al eliminar el usuario se elimine la configuraciÃ³n.
    $sql = "CREATE TABLE IF NOT EXISTS user_configurations (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        role VARCHAR(50) NOT NULL,
        view_type VARCHAR(50) NOT NULL,
        theme VARCHAR(50) NOT NULL,
        font_size VARCHAR(10) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_configurations' created/verified.");

    // 7. Table: user_configurations_history
    // Se eliminan las FK y se dejan Ã­ndices para conservar el historial.
    $sql = "CREATE TABLE IF NOT EXISTS user_configurations_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        config_id INT NOT NULL,
        user_id INT NOT NULL,
        role VARCHAR(50) NOT NULL,
        view_type VARCHAR(50) NOT NULL,
        theme VARCHAR(50) NOT NULL,
        font_size VARCHAR(10) NOT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (config_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_configurations_history' created/verified.");

    // 8. Table: clients
    // Se elimina FK a users; se deja FK a files (ON DELETE SET NULL) y se agrega Ã­ndice para user_id.
    $sql = "CREATE TABLE IF NOT EXISTS clients (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        business_name VARCHAR(255) NOT NULL,
        tax_id VARCHAR(20) NOT NULL,
        email VARCHAR(255) NOT NULL,
        brand_file_id INT DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (brand_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'clients' created/verified.");

    // 9. Table: clients_history
    // Se eliminan las FK para conservar la informaciÃ³n histÃ³rica; se reemplazan por Ã­ndices.
    $sql = "CREATE TABLE IF NOT EXISTS clients_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        client_id INT NOT NULL,
        user_id INT NOT NULL,
        business_name VARCHAR(255) NOT NULL,
        tax_id VARCHAR(20) NOT NULL,
        email VARCHAR(255) NOT NULL,
        brand_file_id INT DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (client_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'clients_history' created/verified.");

    /*
     * Para las tablas restantes, se eliminaron las FK que referencian a otras tablas (o se mantienen aquellas con ON DELETE SET NULL)
     * y se utilizan Ã­ndices para preservar la informaciÃ³n histÃ³rica sin que la restricciÃ³n impida la eliminaciÃ³n.
     */

    // 10. Table: products_services
    // Se mantiene FK para product_image_file_id (ON DELETE SET NULL) y se reemplaza FK de user_id por Ã­ndice.
    // -------------------------------
    // Table: products_services
    // -------------------------------
    $createProductsServicesSql = "CREATE TABLE IF NOT EXISTS products_services (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        description VARCHAR(255) DEFAULT NULL,
        category VARCHAR(100) DEFAULT NULL,
        price DECIMAL(10,2) DEFAULT NULL,
        cost DECIMAL(10,2) DEFAULT NULL,
        difficulty VARCHAR(50) DEFAULT NULL,
        item_type ENUM('product','service') NOT NULL,
        product_image_file_id INT DEFAULT NULL,
        stock INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (product_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createProductsServicesSql, "Table 'products_services' created/verified.");
    
    // -------------------------------
    // Table: products_services_history
    // -------------------------------
    $createProductsServicesHistorySql = "CREATE TABLE IF NOT EXISTS products_services_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        ps_id INT NOT NULL,
        user_id INT NOT NULL,
        description VARCHAR(255) DEFAULT NULL,
        category VARCHAR(100) DEFAULT NULL,
        price DECIMAL(10,2) DEFAULT NULL,
        cost DECIMAL(10,2) DEFAULT NULL,
        difficulty VARCHAR(50) DEFAULT NULL,
        item_type ENUM('product','service') DEFAULT NULL,
        product_image_file_id INT DEFAULT NULL,
        stock INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (ps_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createProductsServicesHistorySql, "Table 'products_services_history' created/verified.");


    // 11. Table: folders
    // Se reemplazan todas las FK por Ã­ndices, salvo las que sean ON DELETE SET NULL.
    $sql = "CREATE TABLE IF NOT EXISTS folders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        parent_id INT DEFAULT NULL,
        folder_image_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (parent_id),
        FOREIGN KEY (folder_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'folders' created/verified.");
    
    // -------------------------------
    // 19. Table: folders_history
    // -------------------------------
    $createFoldersHistorySql = "CREATE TABLE IF NOT EXISTS folders_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        folder_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        parent_id INT DEFAULT NULL,
        folder_image_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (folder_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createFoldersHistorySql, "Table 'folders_history' created/verified.");


    // -------------------------------
    // Table: jobs
    // -------------------------------
    $createJobsSql = "CREATE TABLE IF NOT EXISTS jobs (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id DEFAULT NULL,
        product_service_id INT DEFAULT NULL,
        folder_id INT DEFAULT NULL,
        type_of_work VARCHAR(100) DEFAULT NULL,
        description TEXT DEFAULT NULL,
        status VARCHAR(50) DEFAULT NULL,
        start_datetime DATETIME DEFAULT NULL,
        end_datetime DATETIME DEFAULT NULL,
        multiplicative_value DECIMAL(10,2) DEFAULT 1.00,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        FOREIGN KEY (product_service_id) REFERENCES products_services(id) ON DELETE SET NULL,
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createJobsSql, "Table 'jobs' created/verified.");
    
    // -------------------------------
    // Table: jobs_history
    // -------------------------------
    $createJobsHistorySql = "CREATE TABLE IF NOT EXISTS jobs_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        job_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT DEFAULT NULL,
        product_service_id INT DEFAULT NULL,
        folder_id INT DEFAULT NULL,
        type_of_work VARCHAR(100) DEFAULT NULL,
        description TEXT DEFAULT NULL,
        status VARCHAR(50) DEFAULT NULL,
        start_datetime DATETIME DEFAULT NULL,
        end_datetime DATETIME DEFAULT NULL,
        multiplicative_value DECIMAL(10,2) DEFAULT 1.00,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (job_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createJobsHistorySql, "Table 'jobs_history' created/verified.");


    // -------------------------------
    // Table: sales
    // -------------------------------
    $createSalesSql = "CREATE TABLE IF NOT EXISTS sales (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        product_service_id INT NOT NULL,
        folder_id INT DEFAULT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        amount DECIMAL(10,2) NOT NULL,
        sale_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (product_service_id),
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createSalesSql, "Table 'sales' created/verified.");
    
    // -------------------------------
    // Table: sales_history
    // -------------------------------
    $createSalesHistorySql = "CREATE TABLE IF NOT EXISTS sales_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        sale_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        product_service_id INT NOT NULL,
        folder_id INT DEFAULT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        amount DECIMAL(10,2) NOT NULL,
        sale_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (sale_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createSalesHistorySql, "Table 'sales_history' created/verified.");


    // -------------------------------
    // Table: expenses
    // -------------------------------
    $createExpensesSql = "CREATE TABLE IF NOT EXISTS expenses (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        description VARCHAR(255) NOT NULL,
        category VARCHAR(100) DEFAULT NULL,
        amount DECIMAL(10,2) NOT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        folder_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        expense_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createExpensesSql, "Table 'expenses' created/verified.");
    
    // -------------------------------
    // Table: expenses_history
    // -------------------------------
    $createExpensesHistorySql = "CREATE TABLE IF NOT EXISTS expenses_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        expense_id INT NOT NULL,
        user_id INT NOT NULL,
        description VARCHAR(255) NOT NULL,
        category VARCHAR(100) DEFAULT NULL,
        amount DECIMAL(10,2) NOT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        folder_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        expense_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (expense_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createExpensesHistorySql, "Table 'expenses_history' created/verified.");

    
    // -------------------------------
    // Table: appointments
    // -------------------------------
    $createAppointmentsSql = "CREATE TABLE IF NOT EXISTS appointments (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        job_id INT DEFAULT NULL,
        appointment_date DATE NOT NULL,
        appointment_time TIME NOT NULL,
        location VARCHAR(255) DEFAULT NULL,
        site_image_file_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (job_id),
        FOREIGN KEY (site_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createAppointmentsSql, "Table 'appointments' created/verified.");
    
    // -------------------------------
    // Table: appointments_history
    // -------------------------------
    $createAppointmentsHistorySql = "CREATE TABLE IF NOT EXISTS appointments_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        appointment_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        job_id INT DEFAULT NULL,
        appointment_date DATE NOT NULL,
        appointment_time TIME NOT NULL,
        location VARCHAR(255) DEFAULT NULL,
        site_image_file_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (appointment_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createAppointmentsHistorySql, "Table 'appointments_history' created/verified.");


    // 16. Table: notifications
    // Se reemplaza la FK de user_id por un Ã­ndice.
    $sql = "CREATE TABLE IF NOT EXISTS notifications (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        title VARCHAR(100) NOT NULL,
        notification_type VARCHAR(50) NOT NULL,
        message TEXT NOT NULL,
        action_reference VARCHAR(255) DEFAULT NULL,
        is_read TINYINT(1) NOT NULL DEFAULT 0,
        read_at DATETIME DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'notifications' created/verified.");

    // -------------------------------
    // Table: cash_boxes
    // -------------------------------
    $createCashBoxesSql = "CREATE TABLE IF NOT EXISTS cash_boxes (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        image_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createCashBoxesSql, "Table 'cash_boxes' created/verified.");
    
    // -------------------------------
    // Table: cash_boxes_history
    // -------------------------------
    $createCashBoxesHistorySql = "CREATE TABLE IF NOT EXISTS cash_boxes_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        cash_box_id INT NOT NULL,
        user_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        image_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (cash_box_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createCashBoxesHistorySql, "Table 'cash_boxes_history' created/verified.");

// -------------------------------
// Table: accounting_closings
// -------------------------------
$createAccountingClosingsSql = "CREATE TABLE IF NOT EXISTS accounting_closings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    cash_box_id INT NOT NULL,
    closing_date DATETIME NOT NULL,
    final_balance DECIMAL(10,2) NOT NULL,
    total_income DECIMAL(10,2) NOT NULL,
    total_expenses DECIMAL(10,2) NOT NULL,
    comments TEXT DEFAULT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX (user_id),
    INDEX (cash_box_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
executeSQL($pdo, $createAccountingClosingsSql, "Table 'accounting_closings' created/verified.");

// -------------------------------
// Table: accounting_closings_history
// -------------------------------
$createAccountingClosingsHistorySql = "CREATE TABLE IF NOT EXISTS accounting_closings_history (
    history_id INT AUTO_INCREMENT PRIMARY KEY,
    closing_id INT NOT NULL,
    user_id INT NOT NULL,
    cash_box_id INT NOT NULL,
    closing_date DATETIME NOT NULL,
    final_balance DECIMAL(10,2) NOT NULL,
    total_income DECIMAL(10,2) NOT NULL,
    total_expenses DECIMAL(10,2) NOT NULL,
    comments TEXT DEFAULT NULL,
    changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    changed_by INT DEFAULT NULL,
    operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
    INDEX (closing_id),
    INDEX (user_id),
    INDEX (changed_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
executeSQL($pdo, $createAccountingClosingsHistorySql, "Table 'accounting_closings_history' created/verified.");


    echo "<br/>Installation/Update completed.";
} catch (PDOException $e) {
    echo "Connection or execution error: " . $e->getMessage();
}
?>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: output.txt
Content:
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: .env
Content:
JWT_SECRET=mi_clave_secreta

DB_HOST=localhost
DB_NAME=u650890769_sistema
DB_USER=u650890769_pormauro
DB_PASS=2M~w:F]tl

LOCK_TIME_MINUTES=15
MAX_FAILED_ATTEMPTS=3

# ConfiguraciÃƒÂ³n SMTP para enviar emails
SMTP_HOST=smtp.hostinger.com
SMTP_USER=no-reply@sistema.depros.com.ar
SMTP_PASS=oH*r&+y9K
SMTP_SECURE=ssl
SMTP_PORT=465
SMTP_FROM=no-reply@sistema.depros.com.ar
SMTP_FROM_NAME="Sistema de GestiÃƒÂ³n DEPROS"

# Zona horaria del sistema
TIME_ZONE=America/Argentina/Buenos_Aires

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: .htaccess
Content:
# Activar reescritura de URLs
<IfModule mod_rewrite.c>
    RewriteEngine On

    # Proteger el archivo .env para que no se pueda acceder directamente
    <FilesMatch "^\.env">
        Order allow,deny
        Deny from all
    </FilesMatch>

    # Si el archivo o directorio solicitado no existe, redirigir a index.php
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^.*$ index.php [QSA,L]

    php_flag display_errors on
    php_value error_reporting -1
</IfModule>

<IfModule mod_headers.c>
    # Cabeceras de seguridad bÃƒÂ¡sicas
    Header always set X-Frame-Options "SAMEORIGIN"
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-XSS-Protection "1; mode=block"
</IfModule>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: activate.php
Content:
<?php
// public_html/activate.php

require_once __DIR__ . '/vendor/autoload.php';

use Dotenv\Dotenv;
use App\Models\User;

$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

if (!isset($_GET['token'])) {
    die("Token no proporcionado.");
}

$token = $_GET['token'];
$user = new User();
$result = $user->activateUser($token);

if ($result) {
    echo "Cuenta activada exitosamente. Ya puedes iniciar sesiÃƒÂ³n.";
} else {
    echo "El token es invÃƒÂ¡lido o la cuenta ya estÃƒÂ¡ activada.";
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: composer.json
Content:
{
    "name": "pormauro/sistema",
    "description": "Sistema de gestiÃƒÂ³n de empresas de tecnologÃƒÂ­a",
    "require": {
        "firebase/php-jwt": "^6.11",
        "vlucas/phpdotenv": "^5.6",
        "slim/slim":"^4.0" ,
        "phpmailer/phpmailer": "^6.8",
        "slim/psr7": "^1.7"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "authors": [
        {
            "name": "pormauro"
        }
    ]
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: composer.lock
Content:
{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "4e4096b98c73c8c3be7fefb0514647f4",
    "packages": [
        {
            "name": "fig/http-message-util",
            "version": "1.1.5",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message-util.git",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message-util/zipball/9d94dc0154230ac39e5bf89398b324a86f63f765",
                "reference": "9d94dc0154230ac39e5bf89398b324a86f63f765",
                "shasum": ""
            },
            "require": {
                "php": "^5.3 || ^7.0 || ^8.0"
            },
            "suggest": {
                "psr/http-message": "The package containing the PSR-7 interfaces"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.1.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Fig\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Utility classes and constants for use with PSR-7 (psr/http-message)",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-message-util/issues",
                "source": "https://github.com/php-fig/http-message-util/tree/1.1.5"
            },
            "time": "2020-11-24T22:02:12+00:00"
        },
        {
            "name": "firebase/php-jwt",
            "version": "v6.11.0",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "8f718f4dfc9c5d5f0c994cdfd103921b43592712"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/8f718f4dfc9c5d5f0c994cdfd103921b43592712",
                "reference": "8f718f4dfc9c5d5f0c994cdfd103921b43592712",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.11.0"
            },
            "time": "2025-01-23T05:11:06+00:00"
        },
        {
            "name": "graham-campbell/result-type",
            "version": "v1.1.3",
            "source": {
                "type": "git",
                "url": "https://github.com/GrahamCampbell/Result-Type.git",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/GrahamCampbell/Result-Type/zipball/3ba905c11371512af9d9bdd27d99b782216b6945",
                "reference": "3ba905c11371512af9d9bdd27d99b782216b6945",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3"
            },
            "require-dev": {
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "GrahamCampbell\\ResultType\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "An Implementation Of The Result Type",
            "keywords": [
                "Graham Campbell",
                "GrahamCampbell",
                "Result Type",
                "Result-Type",
                "result"
            ],
            "support": {
                "issues": "https://github.com/GrahamCampbell/Result-Type/issues",
                "source": "https://github.com/GrahamCampbell/Result-Type/tree/v1.1.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/graham-campbell/result-type",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:45:45+00:00"
        },
        {
            "name": "nikic/fast-route",
            "version": "v1.3.0",
            "source": {
                "type": "git",
                "url": "https://github.com/nikic/FastRoute.git",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/nikic/FastRoute/zipball/181d480e08d9476e61381e04a71b34dc0432e812",
                "reference": "181d480e08d9476e61381e04a71b34dc0432e812",
                "shasum": ""
            },
            "require": {
                "php": ">=5.4.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^4.8.35|~5.7"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/functions.php"
                ],
                "psr-4": {
                    "FastRoute\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Nikita Popov",
                    "email": "nikic@php.net"
                }
            ],
            "description": "Fast request router for PHP",
            "keywords": [
                "router",
                "routing"
            ],
            "support": {
                "issues": "https://github.com/nikic/FastRoute/issues",
                "source": "https://github.com/nikic/FastRoute/tree/master"
            },
            "time": "2018-02-13T20:26:39+00:00"
        },
        {
            "name": "phpmailer/phpmailer",
            "version": "v6.9.3",
            "source": {
                "type": "git",
                "url": "https://github.com/PHPMailer/PHPMailer.git",
                "reference": "2f5c94fe7493efc213f643c23b1b1c249d40f47e"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/PHPMailer/PHPMailer/zipball/2f5c94fe7493efc213f643c23b1b1c249d40f47e",
                "reference": "2f5c94fe7493efc213f643c23b1b1c249d40f47e",
                "shasum": ""
            },
            "require": {
                "ext-ctype": "*",
                "ext-filter": "*",
                "ext-hash": "*",
                "php": ">=5.5.0"
            },
            "require-dev": {
                "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
                "doctrine/annotations": "^1.2.6 || ^1.13.3",
                "php-parallel-lint/php-console-highlighter": "^1.0.0",
                "php-parallel-lint/php-parallel-lint": "^1.3.2",
                "phpcompatibility/php-compatibility": "^9.3.5",
                "roave/security-advisories": "dev-latest",
                "squizlabs/php_codesniffer": "^3.7.2",
                "yoast/phpunit-polyfills": "^1.0.4"
            },
            "suggest": {
                "decomplexity/SendOauth2": "Adapter for using XOAUTH2 authentication",
                "ext-mbstring": "Needed to send email in multibyte encoding charset or decode encoded addresses",
                "ext-openssl": "Needed for secure SMTP sending and DKIM signing",
                "greew/oauth2-azure-provider": "Needed for Microsoft Azure XOAUTH2 authentication",
                "hayageek/oauth2-yahoo": "Needed for Yahoo XOAUTH2 authentication",
                "league/oauth2-google": "Needed for Google XOAUTH2 authentication",
                "psr/log": "For optional PSR-3 debug logging",
                "symfony/polyfill-mbstring": "To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)",
                "thenetworg/oauth2-azure": "Needed for Microsoft XOAUTH2 authentication"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "PHPMailer\\PHPMailer\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "LGPL-2.1-only"
            ],
            "authors": [
                {
                    "name": "Marcus Bointon",
                    "email": "phpmailer@synchromedia.co.uk"
                },
                {
                    "name": "Jim Jagielski",
                    "email": "jimjag@gmail.com"
                },
                {
                    "name": "Andy Prevost",
                    "email": "codeworxtech@users.sourceforge.net"
                },
                {
                    "name": "Brent R. Matzelle"
                }
            ],
            "description": "PHPMailer is a full-featured email creation and transfer class for PHP",
            "support": {
                "issues": "https://github.com/PHPMailer/PHPMailer/issues",
                "source": "https://github.com/PHPMailer/PHPMailer/tree/v6.9.3"
            },
            "funding": [
                {
                    "url": "https://github.com/Synchro",
                    "type": "github"
                }
            ],
            "time": "2024-11-24T18:04:13+00:00"
        },
        {
            "name": "phpoption/phpoption",
            "version": "1.9.3",
            "source": {
                "type": "git",
                "url": "https://github.com/schmittjoh/php-option.git",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/schmittjoh/php-option/zipball/e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "reference": "e3fac8b24f56113f7cb96af14958c0dd16330f54",
                "shasum": ""
            },
            "require": {
                "php": "^7.2.5 || ^8.0"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "phpunit/phpunit": "^8.5.39 || ^9.6.20 || ^10.5.28"
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "1.9-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "PhpOption\\": "src/PhpOption/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "Apache-2.0"
            ],
            "authors": [
                {
                    "name": "Johannes M. Schmitt",
                    "email": "schmittjoh@gmail.com",
                    "homepage": "https://github.com/schmittjoh"
                },
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                }
            ],
            "description": "Option Type for PHP",
            "keywords": [
                "language",
                "option",
                "php",
                "type"
            ],
            "support": {
                "issues": "https://github.com/schmittjoh/php-option/issues",
                "source": "https://github.com/schmittjoh/php-option/tree/1.9.3"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/phpoption/phpoption",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:41:07+00:00"
        },
        {
            "name": "psr/container",
            "version": "2.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/container.git",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/container/zipball/c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "reference": "c71ecc56dfe541dbd90c5360474fbc405f8d5963",
                "shasum": ""
            },
            "require": {
                "php": ">=7.4.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Container\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common Container Interface (PHP FIG PSR-11)",
            "homepage": "https://github.com/php-fig/container",
            "keywords": [
                "PSR-11",
                "container",
                "container-interface",
                "container-interop",
                "psr"
            ],
            "support": {
                "issues": "https://github.com/php-fig/container/issues",
                "source": "https://github.com/php-fig/container/tree/2.0.2"
            },
            "time": "2021-11-05T16:47:00+00:00"
        },
        {
            "name": "psr/http-factory",
            "version": "1.1.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-factory.git",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-factory/zipball/2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "reference": "2b4765fddfe3b508ac62f829e852b1501d3f6e8a",
                "shasum": ""
            },
            "require": {
                "php": ">=7.1",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "PSR-17: Common interfaces for PSR-7 HTTP message factories",
            "keywords": [
                "factory",
                "http",
                "message",
                "psr",
                "psr-17",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-factory"
            },
            "time": "2024-04-15T12:06:14+00:00"
        },
        {
            "name": "psr/http-message",
            "version": "2.0",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-message.git",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-message/zipball/402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "reference": "402d35bcb92c70c026d1a6a9883f06b2ead23d71",
                "shasum": ""
            },
            "require": {
                "php": "^7.2 || ^8.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "2.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Message\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP messages",
            "homepage": "https://github.com/php-fig/http-message",
            "keywords": [
                "http",
                "http-message",
                "psr",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-message/tree/2.0"
            },
            "time": "2023-04-04T09:54:51+00:00"
        },
        {
            "name": "psr/http-server-handler",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-handler.git",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-handler/zipball/84c4fb66179be4caaf8e97bd239203245302e7d4",
                "reference": "84c4fb66179be4caaf8e97bd239203245302e7d4",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side request handler",
            "keywords": [
                "handler",
                "http",
                "http-interop",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response",
                "server"
            ],
            "support": {
                "source": "https://github.com/php-fig/http-server-handler/tree/1.0.2"
            },
            "time": "2023-04-10T20:06:20+00:00"
        },
        {
            "name": "psr/http-server-middleware",
            "version": "1.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/http-server-middleware.git",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/http-server-middleware/zipball/c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "reference": "c1481f747daaa6a0782775cd6a8c26a1bf4a3829",
                "shasum": ""
            },
            "require": {
                "php": ">=7.0",
                "psr/http-message": "^1.0 || ^2.0",
                "psr/http-server-handler": "^1.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "1.0.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Http\\Server\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for HTTP server-side middleware",
            "keywords": [
                "http",
                "http-interop",
                "middleware",
                "psr",
                "psr-15",
                "psr-7",
                "request",
                "response"
            ],
            "support": {
                "issues": "https://github.com/php-fig/http-server-middleware/issues",
                "source": "https://github.com/php-fig/http-server-middleware/tree/1.0.2"
            },
            "time": "2023-04-11T06:14:47+00:00"
        },
        {
            "name": "psr/log",
            "version": "3.0.2",
            "source": {
                "type": "git",
                "url": "https://github.com/php-fig/log.git",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/php-fig/log/zipball/f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "reference": "f16e1d5863e37f8d8c2a01719f5b34baa2b714d3",
                "shasum": ""
            },
            "require": {
                "php": ">=8.0.0"
            },
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "3.x-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Psr\\Log\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "PHP-FIG",
                    "homepage": "https://www.php-fig.org/"
                }
            ],
            "description": "Common interface for logging libraries",
            "homepage": "https://github.com/php-fig/log",
            "keywords": [
                "log",
                "psr",
                "psr-3"
            ],
            "support": {
                "source": "https://github.com/php-fig/log/tree/3.0.2"
            },
            "time": "2024-09-11T13:17:53+00:00"
        },
        {
            "name": "ralouphie/getallheaders",
            "version": "3.0.3",
            "source": {
                "type": "git",
                "url": "https://github.com/ralouphie/getallheaders.git",
                "reference": "120b605dfeb996808c31b6477290a714d356e822"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/ralouphie/getallheaders/zipball/120b605dfeb996808c31b6477290a714d356e822",
                "reference": "120b605dfeb996808c31b6477290a714d356e822",
                "shasum": ""
            },
            "require": {
                "php": ">=5.6"
            },
            "require-dev": {
                "php-coveralls/php-coveralls": "^2.1",
                "phpunit/phpunit": "^5 || ^6.5"
            },
            "type": "library",
            "autoload": {
                "files": [
                    "src/getallheaders.php"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ralph Khattar",
                    "email": "ralph.khattar@gmail.com"
                }
            ],
            "description": "A polyfill for getallheaders.",
            "support": {
                "issues": "https://github.com/ralouphie/getallheaders/issues",
                "source": "https://github.com/ralouphie/getallheaders/tree/develop"
            },
            "time": "2019-03-08T08:55:37+00:00"
        },
        {
            "name": "slim/psr7",
            "version": "1.7.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim-Psr7.git",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim-Psr7/zipball/753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "reference": "753e9646def5ff4db1a06e5cf4ef539bfd30f467",
                "shasum": ""
            },
            "require": {
                "fig/http-message-util": "^1.1.5",
                "php": "^8.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.0 || ^2.0",
                "ralouphie/getallheaders": "^3.0",
                "symfony/polyfill-php80": "^1.29"
            },
            "provide": {
                "psr/http-factory-implementation": "^1.0",
                "psr/http-message-implementation": "^1.0 || ^2.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-json": "*",
                "http-interop/http-factory-tests": "^1.1.0",
                "php-http/psr7-integration-tests": "1.3.0",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.2",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "squizlabs/php_codesniffer": "^3.10"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\Psr7\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "http://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                }
            ],
            "description": "Strict PSR-7 implementation",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "http",
                "psr-7",
                "psr7"
            ],
            "support": {
                "issues": "https://github.com/slimphp/Slim-Psr7/issues",
                "source": "https://github.com/slimphp/Slim-Psr7/tree/1.7.0"
            },
            "time": "2024-06-08T14:48:17+00:00"
        },
        {
            "name": "slim/slim",
            "version": "4.14.0",
            "source": {
                "type": "git",
                "url": "https://github.com/slimphp/Slim.git",
                "reference": "5943393b88716eb9e82c4161caa956af63423913"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/slimphp/Slim/zipball/5943393b88716eb9e82c4161caa956af63423913",
                "reference": "5943393b88716eb9e82c4161caa956af63423913",
                "shasum": ""
            },
            "require": {
                "ext-json": "*",
                "nikic/fast-route": "^1.3",
                "php": "^7.4 || ^8.0",
                "psr/container": "^1.0 || ^2.0",
                "psr/http-factory": "^1.1",
                "psr/http-message": "^1.1 || ^2.0",
                "psr/http-server-handler": "^1.0",
                "psr/http-server-middleware": "^1.0",
                "psr/log": "^1.1 || ^2.0 || ^3.0"
            },
            "require-dev": {
                "adriansuter/php-autoload-override": "^1.4",
                "ext-simplexml": "*",
                "guzzlehttp/psr7": "^2.6",
                "httpsoft/http-message": "^1.1",
                "httpsoft/http-server-request": "^1.1",
                "laminas/laminas-diactoros": "^2.17 || ^3",
                "nyholm/psr7": "^1.8",
                "nyholm/psr7-server": "^1.1",
                "phpspec/prophecy": "^1.19",
                "phpspec/prophecy-phpunit": "^2.1",
                "phpstan/phpstan": "^1.11",
                "phpunit/phpunit": "^9.6",
                "slim/http": "^1.3",
                "slim/psr7": "^1.6",
                "squizlabs/php_codesniffer": "^3.10",
                "vimeo/psalm": "^5.24"
            },
            "suggest": {
                "ext-simplexml": "Needed to support XML format in BodyParsingMiddleware",
                "ext-xml": "Needed to support XML format in BodyParsingMiddleware",
                "php-di/php-di": "PHP-DI is the recommended container library to be used with Slim",
                "slim/psr7": "Slim PSR-7 implementation. See https://www.slimframework.com/docs/v4/start/installation.html for more information."
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Slim\\": "Slim"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Josh Lockhart",
                    "email": "hello@joshlockhart.com",
                    "homepage": "https://joshlockhart.com"
                },
                {
                    "name": "Andrew Smith",
                    "email": "a.smith@silentworks.co.uk",
                    "homepage": "http://silentworks.co.uk"
                },
                {
                    "name": "Rob Allen",
                    "email": "rob@akrabat.com",
                    "homepage": "http://akrabat.com"
                },
                {
                    "name": "Pierre Berube",
                    "email": "pierre@lgse.com",
                    "homepage": "http://www.lgse.com"
                },
                {
                    "name": "Gabriel Manricks",
                    "email": "gmanricks@me.com",
                    "homepage": "http://gabrielmanricks.com"
                }
            ],
            "description": "Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs",
            "homepage": "https://www.slimframework.com",
            "keywords": [
                "api",
                "framework",
                "micro",
                "router"
            ],
            "support": {
                "docs": "https://www.slimframework.com/docs/v4/",
                "forum": "https://discourse.slimframework.com/",
                "irc": "irc://irc.freenode.net:6667/slimphp",
                "issues": "https://github.com/slimphp/Slim/issues",
                "rss": "https://www.slimframework.com/blog/feed.rss",
                "slack": "https://slimphp.slack.com/",
                "source": "https://github.com/slimphp/Slim",
                "wiki": "https://github.com/slimphp/Slim/wiki"
            },
            "funding": [
                {
                    "url": "https://opencollective.com/slimphp",
                    "type": "open_collective"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/slim/slim",
                    "type": "tidelift"
                }
            ],
            "time": "2024-06-13T08:54:48+00:00"
        },
        {
            "name": "symfony/polyfill-ctype",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-ctype.git",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-ctype/zipball/a3cc8b044a6ea513310cbd48ef7333b384945638",
                "reference": "a3cc8b044a6ea513310cbd48ef7333b384945638",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-ctype": "*"
            },
            "suggest": {
                "ext-ctype": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Ctype\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Gert de Pagter",
                    "email": "BackEndTea@gmail.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for ctype functions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "ctype",
                "polyfill",
                "portable"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-ctype/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-mbstring",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-mbstring.git",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-mbstring/zipball/85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "reference": "85181ba99b2345b0ef10ce42ecac37612d9fd341",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "provide": {
                "ext-mbstring": "*"
            },
            "suggest": {
                "ext-mbstring": "For best performance"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Mbstring\\": ""
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill for the Mbstring extension",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "mbstring",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-mbstring/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "symfony/polyfill-php80",
            "version": "v1.31.0",
            "source": {
                "type": "git",
                "url": "https://github.com/symfony/polyfill-php80.git",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/symfony/polyfill-php80/zipball/60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "reference": "60328e362d4c2c802a54fcbf04f9d3fb892b4cf8",
                "shasum": ""
            },
            "require": {
                "php": ">=7.2"
            },
            "type": "library",
            "extra": {
                "thanks": {
                    "url": "https://github.com/symfony/polyfill",
                    "name": "symfony/polyfill"
                }
            },
            "autoload": {
                "files": [
                    "bootstrap.php"
                ],
                "psr-4": {
                    "Symfony\\Polyfill\\Php80\\": ""
                },
                "classmap": [
                    "Resources/stubs"
                ]
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "authors": [
                {
                    "name": "Ion Bazan",
                    "email": "ion.bazan@gmail.com"
                },
                {
                    "name": "Nicolas Grekas",
                    "email": "p@tchwork.com"
                },
                {
                    "name": "Symfony Community",
                    "homepage": "https://symfony.com/contributors"
                }
            ],
            "description": "Symfony polyfill backporting some PHP 8.0+ features to lower PHP versions",
            "homepage": "https://symfony.com",
            "keywords": [
                "compatibility",
                "polyfill",
                "portable",
                "shim"
            ],
            "support": {
                "source": "https://github.com/symfony/polyfill-php80/tree/v1.31.0"
            },
            "funding": [
                {
                    "url": "https://symfony.com/sponsor",
                    "type": "custom"
                },
                {
                    "url": "https://github.com/fabpot",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/symfony/symfony",
                    "type": "tidelift"
                }
            ],
            "time": "2024-09-09T11:45:10+00:00"
        },
        {
            "name": "vlucas/phpdotenv",
            "version": "v5.6.1",
            "source": {
                "type": "git",
                "url": "https://github.com/vlucas/phpdotenv.git",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/vlucas/phpdotenv/zipball/a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "reference": "a59a13791077fe3d44f90e7133eb68e7d22eaff2",
                "shasum": ""
            },
            "require": {
                "ext-pcre": "*",
                "graham-campbell/result-type": "^1.1.3",
                "php": "^7.2.5 || ^8.0",
                "phpoption/phpoption": "^1.9.3",
                "symfony/polyfill-ctype": "^1.24",
                "symfony/polyfill-mbstring": "^1.24",
                "symfony/polyfill-php80": "^1.24"
            },
            "require-dev": {
                "bamarni/composer-bin-plugin": "^1.8.2",
                "ext-filter": "*",
                "phpunit/phpunit": "^8.5.34 || ^9.6.13 || ^10.4.2"
            },
            "suggest": {
                "ext-filter": "Required to use the boolean validator."
            },
            "type": "library",
            "extra": {
                "bamarni-bin": {
                    "bin-links": true,
                    "forward-command": false
                },
                "branch-alias": {
                    "dev-master": "5.6-dev"
                }
            },
            "autoload": {
                "psr-4": {
                    "Dotenv\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Graham Campbell",
                    "email": "hello@gjcampbell.co.uk",
                    "homepage": "https://github.com/GrahamCampbell"
                },
                {
                    "name": "Vance Lucas",
                    "email": "vance@vancelucas.com",
                    "homepage": "https://github.com/vlucas"
                }
            ],
            "description": "Loads environment variables from `.env` to `getenv()`, `$_ENV` and `$_SERVER` automagically.",
            "keywords": [
                "dotenv",
                "env",
                "environment"
            ],
            "support": {
                "issues": "https://github.com/vlucas/phpdotenv/issues",
                "source": "https://github.com/vlucas/phpdotenv/tree/v5.6.1"
            },
            "funding": [
                {
                    "url": "https://github.com/GrahamCampbell",
                    "type": "github"
                },
                {
                    "url": "https://tidelift.com/funding/github/packagist/vlucas/phpdotenv",
                    "type": "tidelift"
                }
            ],
            "time": "2024-07-20T21:52:34+00:00"
        }
    ],
    "packages-dev": [],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": [],
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": [],
    "platform-dev": [],
    "plugin-api-version": "2.6.0"
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: debug.php
Content:
<?php
// debug.php - Endpoint de depuraciÃƒÂ³n
// Este archivo mostrarÃƒÂ¡ informaciÃƒÂ³n de la peticiÃƒÂ³n que llega al servidor.

header('Content-Type: application/json; charset=utf-8');

// Recopilar informaciÃƒÂ³n de la solicitud
$method = $_SERVER['REQUEST_METHOD'] ?? '';
$uri = $_SERVER['REQUEST_URI'] ?? '';
$queryParams = $_GET;
$postParams = $_POST;
$rawInput = file_get_contents('php://input');
$headers = function_exists('getallheaders') ? getallheaders() : [];

// Armar la respuesta de depuraciÃƒÂ³n
$response = [
    'method'        => $method,
    'uri'           => $uri,
    'query_params'  => $queryParams,
    'post_params'   => $postParams,
    'raw_input'     => $rawInput,
    'headers'       => $headers,
];

// Imprimir la respuesta en formato JSON
echo json_encode($response, JSON_PRETTY_PRINT);
exit;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: download_test.html
Content:
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Descargar Archivo - Sistema DEPROS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
        }
        input, button {
            padding: 8px;
            margin-bottom: 16px;
            width: 100%;
            max-width: 500px;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

<h2>Descargar Archivo</h2>

<label for="fileId">ID del Archivo:</label>
<input type="text" id="fileId" placeholder="Ej: 123">

<label for="token">Token JWT (Bearer):</label>
<input type="text" id="token" placeholder="Pega tu token aquÃƒÂ­">

<button onclick="fetchFile()">Descargar Archivo</button>

<h3>InformaciÃƒÂ³n del Archivo</h3>
<pre id="fileInfo">Esperando informaciÃƒÂ³n...</pre>

<script>
async function fetchFile() {
    const fileId = document.getElementById('fileId').value;
    const token = document.getElementById('token').value;
    const fileInfoEl = document.getElementById('fileInfo');

    fileInfoEl.textContent = 'Descargando archivo...';

    if (!fileId || !token) {
        alert('Por favor ingresa el ID del archivo y el token.');
        return;
    }

    const url = `https://sistema.depros.com.ar/get_file?file_id=${encodeURIComponent(fileId)}`;

    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            fileInfoEl.textContent = 'Error: ' + errorText;
            return;
        }

        const contentDisposition = response.headers.get('Content-Disposition');
        const fileName = contentDisposition ? contentDisposition.split('filename="')[1].split('"')[0] : 'archivo_desconocido';
        const blob = await response.blob();

        const fileUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = fileUrl;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        fileInfoEl.textContent = `Archivo "${fileName}" descargado correctamente.`;

    } catch (error) {
        fileInfoEl.textContent = 'Error al conectar: ' + error.message;
    }
}
</script>

</body>
</html>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: index.php
Content:
<?php

// public/index.php

require_once __DIR__ . '/vendor/autoload.php';

use Dotenv\Dotenv;
use Slim\Factory\AppFactory;

// Cargar variables de entorno
$dotenv = Dotenv::createMutable(__DIR__); // Busca .env
$dotenv->load();

// Crear la instancia de la aplicaciÃƒÂ³n Slim
$app = AppFactory::create();

// Habilitar el middleware de errores (para desarrollo)
$app->addErrorMiddleware(true, true, true);

// >>> AÃƒâ€˜ADIMOS este middleware de logging <<<
$app->add(new \App\Middleware\ActivityLogMiddleware());

// Establecer cabeceras para la respuesta JSON (opcional, si quieres global)
header('Content-Type: application/json; charset=utf-8');

// Incluir rutas
require_once __DIR__ . '/src/Routes/api.php';

// Ejecutar la app
$app->run();

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: install.php
Content:
    <?php
/**
 * install.php
 *
 * Script to install or update the database.
 *
 * - If the "users" table does not exist, it creates it with the complete structure.
 *   It is assumed that if it exists, it already has the required structure.
 *
 * - Creates/verifies the following tables:
 *      users, files, activity_log,
 *      user_profile, user_profile_history, user_configurations, user_configurations_history,
 *      clients, clients_history, products_services, folders, jobs, sales, expenses,
 *      appointments, notifications, cash_boxes, accounting_closings.
 *
 * For historical data (clients_history, user_profile_history, etc.) the foreign key constraints
 * referencing users (or clients, etc.) have been removed (or replaced by indexes)
 * so that, upon deletion of the user, the historical data is preserved.
 *
 * Only in user_profile and user_configurations we keep the FK to users with ON DELETE CASCADE.
 *
 * Images and documents are referenced via the "files" table.
 */

require_once __DIR__ . '/vendor/autoload.php';
use Dotenv\Dotenv;

// Load environment variables from .env
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

// Database credentials
$db_host = $_ENV['DB_HOST'] ?? 'localhost';
$db_name = $_ENV['DB_NAME'] ?? 'my_db';
$db_user = $_ENV['DB_USER'] ?? 'root';
$db_pass = $_ENV['DB_PASS'] ?? '';

try {
    $dsn = "mysql:host={$db_host};dbname={$db_name};charset=utf8mb4";
    $pdo = new PDO($dsn, $db_user, $db_pass);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // Helper function to execute SQL in a standardized way
    function executeSQL(PDO $pdo, string $sql, string $successMessage): void {
        try {
            $pdo->exec($sql);
            echo $successMessage . "<br/>";
        } catch (PDOException $e) {
            echo "Error: " . $e->getMessage() . "<br/>";
        }
    }

    // -------------------------------
    // 1. Table: users
    // -------------------------------
    $stmt = $pdo->query("SHOW TABLES LIKE 'users'");
    $tableExists = $stmt->fetch();
    if (!$tableExists) {
        $createSql = "CREATE TABLE users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            username VARCHAR(255) NOT NULL UNIQUE,
            email VARCHAR(255) NOT NULL UNIQUE,
            password VARCHAR(255) NOT NULL,
            api_token VARCHAR(255) DEFAULT NULL,
            failed_attempts INT NOT NULL DEFAULT 0,
            locked_until DATETIME DEFAULT NULL,
            password_reset_token VARCHAR(255) DEFAULT NULL,
            password_reset_expires DATETIME DEFAULT NULL,
            activation_token VARCHAR(255) DEFAULT NULL,
            activated TINYINT(1) NOT NULL DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
        executeSQL($pdo, $createSql, "Table 'users' created successfully.");
    } else {
        echo "Table 'users' already exists. Verification completed.<br/>";
    }

    // -------------------------------
    // 20. Table: permissions
    // -------------------------------
    $createPermissionsSql = "CREATE TABLE IF NOT EXISTS permissions (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT DEFAULT NULL,
        sector VARCHAR(100) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (sector)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createPermissionsSql, "Table 'permissions' created/verified.");
    
    // -------------------------------
    // 21. Table: permissions_history
    // -------------------------------
    $createPermissionsHistorySql = "CREATE TABLE IF NOT EXISTS permissions_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        permission_id INT NOT NULL,
        user_id INT DEFAULT NULL,
        sector VARCHAR(100) NOT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (permission_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createPermissionsHistorySql, "Table 'permissions_history' created/verified.");
    
    
    // -------------------------------
    // 2. Table: files
    // -------------------------------
    // En vez de FK a users, solo ÃƒÂ­ndice para conservar la info histÃƒÂ³rica.
    $createFilesSql = "CREATE TABLE IF NOT EXISTS files (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        original_name VARCHAR(255) NOT NULL,
        file_type VARCHAR(100) NOT NULL,
        file_size INT NOT NULL,
        file_data LONGBLOB NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createFilesSql, "Table 'files' created/verified.");

    // -------------------------------
    // 3. Table: activity_log
    // -------------------------------
    // Ya se usa INDEX en lugar de FK para user_id.
    $createActivityLogSql = "CREATE TABLE IF NOT EXISTS activity_log (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NULL,
        route VARCHAR(255) NOT NULL,
        method VARCHAR(10) NOT NULL,
        ip_address VARCHAR(45) NOT NULL,
        user_agent TEXT,
        action_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        status_code INT NOT NULL,
        message TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (route),
        INDEX (ip_address)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createActivityLogSql, "Table 'activity_log' created/verified.");

    // ===================================================
    // Complementary tables (without is_deleted and edit_id)
    // ===================================================

    // 4. Table: user_profile
    // Se mantiene FK a users para que al eliminar el usuario se elimine el perfil.
    $sql = "CREATE TABLE IF NOT EXISTS user_profile (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        full_name VARCHAR(255) DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        cuit VARCHAR(20) DEFAULT NULL,
        profile_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (profile_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_profile' created/verified.");

    // 5. Table: user_profile_history
    // Se eliminan las FK y se dejan ÃƒÂ­ndices para conservar la informaciÃƒÂ³n histÃƒÂ³rica.
    $sql = "CREATE TABLE IF NOT EXISTS user_profile_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        profile_id INT NOT NULL,
        user_id INT NOT NULL,
        full_name VARCHAR(255) NOT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        cuit VARCHAR(20) DEFAULT NULL,
        profile_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (profile_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_profile_history' created/verified.");

    // 6. Table: user_configurations
    // Se mantiene FK a users para que al eliminar el usuario se elimine la configuraciÃƒÂ³n.
    $sql = "CREATE TABLE IF NOT EXISTS user_configurations (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        role VARCHAR(50) NOT NULL,
        view_type VARCHAR(50) NOT NULL,
        theme VARCHAR(50) NOT NULL,
        font_size VARCHAR(10) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_configurations' created/verified.");

    // 7. Table: user_configurations_history
    // Se eliminan las FK y se dejan ÃƒÂ­ndices para conservar el historial.
    $sql = "CREATE TABLE IF NOT EXISTS user_configurations_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        config_id INT NOT NULL,
        user_id INT NOT NULL,
        role VARCHAR(50) NOT NULL,
        view_type VARCHAR(50) NOT NULL,
        theme VARCHAR(50) NOT NULL,
        font_size VARCHAR(10) NOT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (config_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'user_configurations_history' created/verified.");

    // 8. Table: clients
    // Se elimina FK a users; se deja FK a files (ON DELETE SET NULL) y se agrega ÃƒÂ­ndice para user_id.
    $sql = "CREATE TABLE IF NOT EXISTS clients (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        business_name VARCHAR(255) NOT NULL,
        tax_id VARCHAR(20) NOT NULL,
        email VARCHAR(255) NOT NULL,
        brand_file_id INT DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (brand_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'clients' created/verified.");

    // 9. Table: clients_history
    // Se eliminan las FK para conservar la informaciÃƒÂ³n histÃƒÂ³rica; se reemplazan por ÃƒÂ­ndices.
    $sql = "CREATE TABLE IF NOT EXISTS clients_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        client_id INT NOT NULL,
        user_id INT NOT NULL,
        business_name VARCHAR(255) NOT NULL,
        tax_id VARCHAR(20) NOT NULL,
        email VARCHAR(255) NOT NULL,
        brand_file_id INT DEFAULT NULL,
        phone VARCHAR(50) DEFAULT NULL,
        address VARCHAR(255) DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (client_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'clients_history' created/verified.");

    /*
     * Para las tablas restantes, se eliminaron las FK que referencian a otras tablas (o se mantienen aquellas con ON DELETE SET NULL)
     * y se utilizan ÃƒÂ­ndices para preservar la informaciÃƒÂ³n histÃƒÂ³rica sin que la restricciÃƒÂ³n impida la eliminaciÃƒÂ³n.
     */

    // 10. Table: products_services
    // Se mantiene FK para product_image_file_id (ON DELETE SET NULL) y se reemplaza FK de user_id por ÃƒÂ­ndice.
    // -------------------------------
    // Table: products_services
    // -------------------------------
    $createProductsServicesSql = "CREATE TABLE IF NOT EXISTS products_services (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        description VARCHAR(255) DEFAULT NULL,
        category VARCHAR(100) DEFAULT NULL,
        price DECIMAL(10,2) DEFAULT NULL,
        cost DECIMAL(10,2) DEFAULT NULL,
        difficulty VARCHAR(50) DEFAULT NULL,
        item_type ENUM('product','service') NOT NULL,
        product_image_file_id INT DEFAULT NULL,
        stock INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (product_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createProductsServicesSql, "Table 'products_services' created/verified.");
    
    // -------------------------------
    // Table: products_services_history
    // -------------------------------
    $createProductsServicesHistorySql = "CREATE TABLE IF NOT EXISTS products_services_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        ps_id INT NOT NULL,
        user_id INT NOT NULL,
        description VARCHAR(255) DEFAULT NULL,
        category VARCHAR(100) DEFAULT NULL,
        price DECIMAL(10,2) DEFAULT NULL,
        cost DECIMAL(10,2) DEFAULT NULL,
        difficulty VARCHAR(50) DEFAULT NULL,
        item_type ENUM('product','service') DEFAULT NULL,
        product_image_file_id INT DEFAULT NULL,
        stock INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (ps_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createProductsServicesHistorySql, "Table 'products_services_history' created/verified.");


    // 11. Table: folders
    // Se reemplazan todas las FK por ÃƒÂ­ndices, salvo las que sean ON DELETE SET NULL.
    $sql = "CREATE TABLE IF NOT EXISTS folders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        parent_id INT DEFAULT NULL,
        folder_image_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (parent_id),
        FOREIGN KEY (folder_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'folders' created/verified.");
    
    // -------------------------------
    // 19. Table: folders_history
    // -------------------------------
    $createFoldersHistorySql = "CREATE TABLE IF NOT EXISTS folders_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        folder_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        parent_id INT DEFAULT NULL,
        folder_image_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (folder_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createFoldersHistorySql, "Table 'folders_history' created/verified.");


    // -------------------------------
    // Table: jobs
    // -------------------------------
    $createJobsSql = "CREATE TABLE IF NOT EXISTS jobs (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id DEFAULT NULL,
        product_service_id INT DEFAULT NULL,
        folder_id INT DEFAULT NULL,
        type_of_work VARCHAR(100) DEFAULT NULL,
        description TEXT DEFAULT NULL,
        status VARCHAR(50) DEFAULT NULL,
        start_datetime DATETIME DEFAULT NULL,
        end_datetime DATETIME DEFAULT NULL,
        multiplicative_value DECIMAL(10,2) DEFAULT 1.00,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        FOREIGN KEY (product_service_id) REFERENCES products_services(id) ON DELETE SET NULL,
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createJobsSql, "Table 'jobs' created/verified.");
    
    // -------------------------------
    // Table: jobs_history
    // -------------------------------
    $createJobsHistorySql = "CREATE TABLE IF NOT EXISTS jobs_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        job_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT DEFAULT NULL,
        product_service_id INT DEFAULT NULL,
        folder_id INT DEFAULT NULL,
        type_of_work VARCHAR(100) DEFAULT NULL,
        description TEXT DEFAULT NULL,
        status VARCHAR(50) DEFAULT NULL,
        start_datetime DATETIME DEFAULT NULL,
        end_datetime DATETIME DEFAULT NULL,
        multiplicative_value DECIMAL(10,2) DEFAULT 1.00,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (job_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createJobsHistorySql, "Table 'jobs_history' created/verified.");


    // -------------------------------
    // Table: sales
    // -------------------------------
    $createSalesSql = "CREATE TABLE IF NOT EXISTS sales (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        product_service_id INT NOT NULL,
        folder_id INT DEFAULT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        amount DECIMAL(10,2) NOT NULL,
        sale_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (product_service_id),
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createSalesSql, "Table 'sales' created/verified.");
    
    // -------------------------------
    // Table: sales_history
    // -------------------------------
    $createSalesHistorySql = "CREATE TABLE IF NOT EXISTS sales_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        sale_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        product_service_id INT NOT NULL,
        folder_id INT DEFAULT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        amount DECIMAL(10,2) NOT NULL,
        sale_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (sale_id),
        INDEX (user_id),
        INDEX (client_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createSalesHistorySql, "Table 'sales_history' created/verified.");


    // -------------------------------
    // Table: expenses
    // -------------------------------
    $createExpensesSql = "CREATE TABLE IF NOT EXISTS expenses (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        description VARCHAR(255) NOT NULL,
        category VARCHAR(100) DEFAULT NULL,
        amount DECIMAL(10,2) NOT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        folder_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        expense_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createExpensesSql, "Table 'expenses' created/verified.");
    
    // -------------------------------
    // Table: expenses_history
    // -------------------------------
    $createExpensesHistorySql = "CREATE TABLE IF NOT EXISTS expenses_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        expense_id INT NOT NULL,
        user_id INT NOT NULL,
        description VARCHAR(255) NOT NULL,
        category VARCHAR(100) DEFAULT NULL,
        amount DECIMAL(10,2) NOT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        folder_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        expense_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (expense_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createExpensesHistorySql, "Table 'expenses_history' created/verified.");

    
    // -------------------------------
    // Table: appointments
    // -------------------------------
    $createAppointmentsSql = "CREATE TABLE IF NOT EXISTS appointments (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        job_id INT DEFAULT NULL,
        appointment_date DATE NOT NULL,
        appointment_time TIME NOT NULL,
        location VARCHAR(255) DEFAULT NULL,
        site_image_file_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        INDEX (client_id),
        INDEX (job_id),
        FOREIGN KEY (site_image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createAppointmentsSql, "Table 'appointments' created/verified.");
    
    // -------------------------------
    // Table: appointments_history
    // -------------------------------
    $createAppointmentsHistorySql = "CREATE TABLE IF NOT EXISTS appointments_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        appointment_id INT NOT NULL,
        user_id INT NOT NULL,
        client_id INT NOT NULL,
        job_id INT DEFAULT NULL,
        appointment_date DATE NOT NULL,
        appointment_time TIME NOT NULL,
        location VARCHAR(255) DEFAULT NULL,
        site_image_file_id INT DEFAULT NULL,
        attached_files TEXT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (appointment_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createAppointmentsHistorySql, "Table 'appointments_history' created/verified.");


    // 16. Table: notifications
    // Se reemplaza la FK de user_id por un ÃƒÂ­ndice.
    $sql = "CREATE TABLE IF NOT EXISTS notifications (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        title VARCHAR(100) NOT NULL,
        notification_type VARCHAR(50) NOT NULL,
        message TEXT NOT NULL,
        action_reference VARCHAR(255) DEFAULT NULL,
        is_read TINYINT(1) NOT NULL DEFAULT 0,
        read_at DATETIME DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $sql, "Table 'notifications' created/verified.");

    // -------------------------------
    // Table: cash_boxes
    // -------------------------------
    $createCashBoxesSql = "CREATE TABLE IF NOT EXISTS cash_boxes (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        image_file_id INT DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX (user_id),
        FOREIGN KEY (image_file_id) REFERENCES files(id) ON DELETE SET NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createCashBoxesSql, "Table 'cash_boxes' created/verified.");
    
    // -------------------------------
    // Table: cash_boxes_history
    // -------------------------------
    $createCashBoxesHistorySql = "CREATE TABLE IF NOT EXISTS cash_boxes_history (
        history_id INT AUTO_INCREMENT PRIMARY KEY,
        cash_box_id INT NOT NULL,
        user_id INT NOT NULL,
        name VARCHAR(255) NOT NULL,
        image_file_id INT DEFAULT NULL,
        changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        changed_by INT DEFAULT NULL,
        operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
        INDEX (cash_box_id),
        INDEX (user_id),
        INDEX (changed_by)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
    executeSQL($pdo, $createCashBoxesHistorySql, "Table 'cash_boxes_history' created/verified.");

// -------------------------------
// Table: accounting_closings
// -------------------------------
$createAccountingClosingsSql = "CREATE TABLE IF NOT EXISTS accounting_closings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    cash_box_id INT NOT NULL,
    closing_date DATETIME NOT NULL,
    final_balance DECIMAL(10,2) NOT NULL,
    total_income DECIMAL(10,2) NOT NULL,
    total_expenses DECIMAL(10,2) NOT NULL,
    comments TEXT DEFAULT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX (user_id),
    INDEX (cash_box_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
executeSQL($pdo, $createAccountingClosingsSql, "Table 'accounting_closings' created/verified.");

// -------------------------------
// Table: accounting_closings_history
// -------------------------------
$createAccountingClosingsHistorySql = "CREATE TABLE IF NOT EXISTS accounting_closings_history (
    history_id INT AUTO_INCREMENT PRIMARY KEY,
    closing_id INT NOT NULL,
    user_id INT NOT NULL,
    cash_box_id INT NOT NULL,
    closing_date DATETIME NOT NULL,
    final_balance DECIMAL(10,2) NOT NULL,
    total_income DECIMAL(10,2) NOT NULL,
    total_expenses DECIMAL(10,2) NOT NULL,
    comments TEXT DEFAULT NULL,
    changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    changed_by INT DEFAULT NULL,
    operation_type ENUM('CREATION', 'UPDATE', 'DELETION') NOT NULL,
    INDEX (closing_id),
    INDEX (user_id),
    INDEX (changed_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;";
executeSQL($pdo, $createAccountingClosingsHistorySql, "Table 'accounting_closings_history' created/verified.");


    echo "<br/>Installation/Update completed.";
} catch (PDOException $e) {
    echo "Connection or execution error: " . $e->getMessage();
}
?>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: reset_password_form.php
Content:
<?php
// reset_password_form.php

// Se espera que el token llegue como parÃ¡metro GET: ?token=...
$token = $_GET['token'] ?? '';
if (!$token) {
    die("Token no proporcionado.");
}
?>
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Restablecer ContraseÃ±a</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      margin: 0;
      padding: 0;
    }
    .container {
      width: 100%;
      max-width: 400px;
      background: #fff;
      margin: 50px auto;
      padding: 20px;
      box-shadow: 0px 0px 10px rgba(0,0,0,0.1);
    }
    h2 {
      text-align: center;
      margin-bottom: 20px;
    }
    .form-group {
      position: relative;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
    }
    input[type="password"],
    input[type="text"] {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
    }
    .toggle-password {
      position: absolute;
      right: 10px;
      top: 40px;
      cursor: pointer;
      user-select: none;
    }
    button {
      width: 100%;
      padding: 10px;
      background: #007BFF;
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 1rem;
    }
    button:hover {
      background: #0056b3;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Restablecer ContraseÃ±a</h2>
    <form id="resetForm">
      <!-- Se incluye el token como campo oculto -->
      <input type="hidden" name="token" value="<?php echo htmlspecialchars($token); ?>">
      <div class="form-group">
        <label for="new_password">Nueva ContraseÃ±a:</label>
        <input type="password" id="new_password" name="new_password" required>
        <span class="toggle-password" onclick="togglePassword('new_password')">&#128065;</span>
      </div>
      <div class="form-group">
        <label for="confirm_password">Confirmar ContraseÃ±a:</label>
        <input type="password" id="confirm_password" name="confirm_password" required>
        <span class="toggle-password" onclick="togglePassword('confirm_password')">&#128065;</span>
      </div>
      <button type="submit">Restablecer ContraseÃ±a</button>
    </form>
  </div>

  <script>
    // FunciÃ³n para alternar la visibilidad del campo de contraseÃ±a
    function togglePassword(id) {
      var input = document.getElementById(id);
      input.type = (input.type === "password") ? "text" : "password";
    }

    // Manejo del envÃ­o del formulario usando fetch
    document.getElementById('resetForm').addEventListener('submit', function(e) {
      e.preventDefault();
      var token = document.querySelector('input[name="token"]').value;
      var newPassword = document.getElementById('new_password').value;
      var confirmPassword = document.getElementById('confirm_password').value;

      if (newPassword !== confirmPassword) {
        alert("Las contraseÃ±as no coinciden.");
        return;
      }

      // Enviar la peticiÃ³n al endpoint /reset_password
      fetch('/reset_password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // Se envÃ­a el token en el header Authorization
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
          new_password: newPassword,
          confirm_password: confirmPassword
        })
      })
      .then(response => response.json())
      .then(data => {
        alert(data.message || data.error);
        // Si se actualiza correctamente, se puede redirigir al login
        if (data.message) {
          window.location.href = '/login';
        }
      })
      .catch(error => {
        console.error('Error:', error);
        alert("OcurriÃ³ un error al restablecer la contraseÃ±a.");
      });
    });
  </script>
</body>
</html>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api
File: uninstall.php
Content:
<?php
/**
 * uninstall.php
 *
 * Script to uninstall (drop) the database tables.
 * It disables foreign key checks, drops all tables,
 * and then re-enables the foreign key checks.
 */

require_once __DIR__ . '/vendor/autoload.php';
use Dotenv\Dotenv;

// Load environment variables from .env
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

// Database credentials
$db_host = $_ENV['DB_HOST'] ?? 'localhost';
$db_name = $_ENV['DB_NAME'] ?? 'my_db';
$db_user = $_ENV['DB_USER'] ?? 'root';
$db_pass = $_ENV['DB_PASS'] ?? '';

try {
    $dsn = "mysql:host={$db_host};dbname={$db_name};charset=utf8mb4";
    $pdo = new PDO($dsn, $db_user, $db_pass);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    // Disable foreign key checks
    $pdo->exec("SET FOREIGN_KEY_CHECKS = 0;");

    // List of tables to drop in order that minimizes FK issues.
    // Se incluye todas las tablas definidas en el instalador:
    $tables = [
        'accounting_closings_history',
        'accounting_closings',
        'cash_boxes_history',
        'cash_boxes',
        'appointments_history',
        'appointments',
        'expenses_history',
        'expenses',
        'sales_history',
        'sales',
        'jobs_history',
        'jobs',
        'folders_history',
        'folders',
        'products_services_history',
        'products_services',
        'clients_history',
        'clients',
        'user_configurations_history',
        'user_configurations',
        'user_profile_history',
        'user_profile',
        'notifications',
        'activity_log',
        'files',
        'permissions',
        'users'
    ];

    foreach ($tables as $table) {
        $sql = "DROP TABLE IF EXISTS `$table`;";
        $pdo->exec($sql);
        echo "Table '$table' dropped.<br/>";
    }

    // Re-enable foreign key checks
    $pdo->exec("SET FOREIGN_KEY_CHECKS = 1;");

    echo "<br/>Uninstallation completed successfully.";
} catch (PDOException $e) {
    echo "Error during uninstallation: " . $e->getMessage();
}
?>

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Config
File: Database.php
Content:
<?php
namespace App\Config;

use PDO;
use PDOException;

class Database
{
    private $host;
    private $db;
    private $user;
    private $pass;
    public $conn;

    public function __construct()
    {
        $this->host = $_ENV['DB_HOST'] ?? 'localhost';
        $this->db   = $_ENV['DB_NAME'] ?? 'mi_db';
        $this->user = $_ENV['DB_USER'] ?? 'root';
        $this->pass = $_ENV['DB_PASS'] ?? '';
    }

    public function connect()
    {
        $this->conn = null;
        try {
            $dsn = "mysql:host={$this->host};dbname={$this->db};charset=utf8mb4";
            $this->conn = new PDO($dsn, $this->user, $this->pass);
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } catch (PDOException $e) {
            die("Error de conexiÃ³n: " . $e->getMessage());
        }
        return $this->conn;
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: AccountingClosingsController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\AccountingClosings;
use App\History\AccountingClosingsHistory;
use App\Helpers\JwtHelper;

class AccountingClosingsController {

    // Lista todos los cierres contables del usuario autenticado
    public function listClosings(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $closingsModel = new AccountingClosings();
        $closings = $closingsModel->listAllByUser($userId);
        $data = ['accounting_closings' => $closings];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Obtiene un cierre contable por su ID (verificando que pertenezca al usuario)
    public function getClosing(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Closing ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $closingsModel = new AccountingClosings();
        $closing = $closingsModel->findById($id);
    /**    if(!$closing || $closing['user_id'] != $userId){
            $data = ['error' => 'Closing not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['accounting_closing' => $closing];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea un nuevo cierre contable para el usuario autenticado
    public function addClosing(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: cash_box_id, closing_date, final_balance, total_income, total_expenses
        if (!isset($body['cash_box_id'], $body['closing_date'], $body['final_balance'], $body['total_income'], $body['total_expenses'])) {
            $data = ['error' => 'Missing required fields: cash_box_id, closing_date, final_balance, total_income, total_expenses'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $body['user_id'] = $userId;
        $body['comments'] = $body['comments'] ?? null;
        
        $closingsModel = new AccountingClosings();
        $newClosingId = $closingsModel->create($body);
        if(!$newClosingId){
            $data = ['error' => 'Error creating closing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de CREATION
        $history = new AccountingClosingsHistory();
        $history->insertHistory(
            $newClosingId,
            $userId,
            $body['cash_box_id'],
            $body['closing_date'],
            $body['final_balance'],
            $body['total_income'],
            $body['total_expenses'],
            $body['comments'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Accounting closing created successfully', 'closing_id' => $newClosingId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza un cierre contable; verifica que pertenezca al usuario autenticado
    public function updateClosing(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Closing ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $closingsModel = new AccountingClosings();
        $existingClosing = $closingsModel->findById($id);
     /*   if(!$existingClosing || $existingClosing['user_id'] != $userId){
            $data = ['error' => 'Closing not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['cash_box_id'], $body['closing_date'], $body['final_balance'], $body['total_income'], $body['total_expenses'])) {
            $data = ['error' => 'Missing required fields: cash_box_id, closing_date, final_balance, total_income, total_expenses'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $body['comments'] = $body['comments'] ?? null;
        $updateResult = $closingsModel->update($id, $body);
        if(!$updateResult){
            $data = ['error' => 'Error updating closing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new AccountingClosingsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['cash_box_id'],
            $body['closing_date'],
            $body['final_balance'],
            $body['total_income'],
            $body['total_expenses'],
            $body['comments'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Accounting closing updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina un cierre contable; registra historial previo
    public function deleteClosing(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Closing ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $closingsModel = new AccountingClosings();
        $existingClosing = $closingsModel->findById($id);
    /*    if(!$existingClosing || $existingClosing['user_id'] != $userId){
            $data = ['error' => 'Closing not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new AccountingClosingsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingClosing['cash_box_id'],
            $existingClosing['closing_date'],
            $existingClosing['final_balance'],
            $existingClosing['total_income'],
            $existingClosing['total_expenses'],
            $existingClosing['comments'],
            $userId,
            'DELETION'
        );
        $deleteResult = $closingsModel->delete($id);
        if(!$deleteResult){
            $data = ['error' => 'Error deleting closing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Accounting closing deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de un cierre contable por su ID
    public function listClosingHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Closing ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $closingsModel = new AccountingClosings();
        $closing = $closingsModel->findById($id);
    /*    if(!$closing || $closing['user_id'] != $userId){
            $data = ['error' => 'Closing not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $history = new AccountingClosingsHistory();
        $historyRecords = $history->listHistoryByClosingId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: AppointmentsController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Appointments;
use App\History\AppointmentsHistory;
use App\Helpers\JwtHelper;

class AppointmentsController {

    // Lista todos los appointments para el usuario autenticado
    public function listAppointments(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $appointmentsModel = new Appointments();
        $appointments = $appointmentsModel->listAllByUser($userId);
        $data = ['appointments' => $appointments];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Obtiene un appointment por su ID (verificando que pertenezca al usuario)
    public function getAppointment(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Appointment ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $appointmentsModel = new Appointments();
        $appointment = $appointmentsModel->findById($id);
   /*     if(!$appointment || $appointment['user_id'] != $userId){
            $data = ['error' => 'Appointment not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type','application/json');
        }*/
        $data = ['appointment' => $appointment];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Crea un nuevo appointment para el usuario autenticado
    public function addAppointment(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: client_id, appointment_date, appointment_time, location
        if (!isset($body['client_id'], $body['appointment_date'], $body['appointment_time'], $body['location'])) {
            $data = ['error' => 'Missing required fields: client_id, appointment_date, appointment_time, location'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $body['user_id'] = $userId;
        // Opcionales: job_id, site_image_file_id, attached_files
        $body['job_id'] = $body['job_id'] ?? null;
        $body['site_image_file_id'] = $body['site_image_file_id'] ?? null;
        $body['attached_files'] = $body['attached_files'] ?? null;
        
        $appointmentsModel = new Appointments();
        $newAppointmentId = $appointmentsModel->create($body);
        if(!$newAppointmentId){
            $data = ['error' => 'Error creating appointment'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type','application/json');
        }
        
        // Registrar historial de CREATION
        $history = new AppointmentsHistory();
        $history->insertHistory(
            $newAppointmentId,
            $userId,
            $body['client_id'],
            $body['job_id'],
            $body['appointment_date'],
            $body['appointment_time'],
            $body['location'],
            $body['site_image_file_id'],
            $body['attached_files'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Appointment created successfully', 'appointment_id' => $newAppointmentId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Actualiza un appointment; verifica que pertenezca al usuario autenticado
    public function updateAppointment(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Appointment ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $appointmentsModel = new Appointments();
        $existingAppointment = $appointmentsModel->findById($id);
     /*   if(!$existingAppointment || $existingAppointment['user_id'] != $userId){
            $data = ['error' => 'Appointment not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type','application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['client_id'], $body['appointment_date'], $body['appointment_time'], $body['location'])) {
            $data = ['error' => 'Missing required fields: client_id, appointment_date, appointment_time, location'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $body['job_id'] = $body['job_id'] ?? null;
        $body['site_image_file_id'] = $body['site_image_file_id'] ?? null;
        $body['attached_files'] = $body['attached_files'] ?? null;
        $updateResult = $appointmentsModel->update($id, $body);
        if(!$updateResult){
            $data = ['error' => 'Error updating appointment'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type','application/json');
        }
        // Registrar historial de UPDATE
        $history = new AppointmentsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['client_id'],
            $body['job_id'],
            $body['appointment_date'],
            $body['appointment_time'],
            $body['location'],
            $body['site_image_file_id'],
            $body['attached_files'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Appointment updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Elimina un appointment; registra historial previo
    public function deleteAppointment(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Appointment ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $appointmentsModel = new Appointments();
        $existingAppointment = $appointmentsModel->findById($id);
     /*   if(!$existingAppointment || $existingAppointment['user_id'] != $userId){
            $data = ['error' => 'Appointment not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type','application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new AppointmentsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingAppointment['client_id'],
            $existingAppointment['job_id'],
            $existingAppointment['appointment_date'],
            $existingAppointment['appointment_time'],
            $existingAppointment['location'],
            $existingAppointment['site_image_file_id'],
            $existingAppointment['attached_files'],
            $userId,
            'DELETION'
        );
        $deleteResult = $appointmentsModel->delete($id);
        if(!$deleteResult){
            $data = ['error' => 'Error deleting appointment'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type','application/json');
        }
        $data = ['message' => 'Appointment deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Lista el historial de un appointment por su ID
    public function listAppointmentHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Appointment ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $appointmentsModel = new Appointments();
        $appointment = $appointmentsModel->findById($id);
     /*   if(!$appointment || $appointment['user_id'] != $userId){
            $data = ['error' => 'Appointment not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type','application/json');
        }*/
        $history = new AppointmentsHistory();
        $historyRecords = $history->listHistoryByAppointmentId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: AuthController.php
Content:
<?php
namespace App\Controllers;

use App\Models\User;
use App\Helpers\JwtHelper;
use App\Mail\EmailSender;
use App\Mail\Templates\ActivationEmail;
use App\Mail\Templates\ResetPasswordEmail;

class AuthController
{
    // Registro: se requiere username, email y password
    public function register($data)
    {
        $username = $data['username'] ?? null;
        $email    = $data['email'] ?? null;
        $password = $data['password'] ?? null;
    
        if (!$username || !$email || !$password) {
            return ['error' => 'Faltan campos (username, email, password)'];
        }
    
        $userModel = new User();
        // Verificar si ya existe usuario con ese username o email
        if ($userModel->findByEmail($email) || $userModel->findByUsername($username)) {
            return ['error' => 'El usuario ya existe'];
        }
    
        // Hashear la contraseÃ±a
        $hash = password_hash($password, PASSWORD_BCRYPT);
    
        // Crear el usuario (sin activar aÃºn)
        $ok = $userModel->createUser($username, $email, $hash);
        if ($ok) {
            // Obtener el ID del usuario insertado
            $userId = $userModel->getLastInsertId();
    
            // ***** CREAR AUTOMÃ�TICAMENTE EL PERFIL DEL USUARIO *****
            $profileModel = new \App\Models\UserProfile();
            $profileData = [
                'user_id' => $userId,
                'full_name' => $username, // Puedes usar el nombre de usuario o dejarlo vacÃ­o
                'phone' => '',
                'address' => '',
                'cuit' => '',
                'profile_file_id' => null
            ];
            $profileModel->create($profileData);
            
            // ***** CREAR AUTOMÃ�TICAMENTE LA CONFIGURACIÃ“N DEL USUARIO *****
            $configModel = new \App\Models\UserConfigurations();
            $configData = [
                'user_id' => $userId,
                'role' => 'usuario',       // Define el rol por defecto
                'view_type' => 'default',  // Valor por defecto para la vista
                'theme' => 'light',        // Tema por defecto (o el que prefieras)
                'font_size' => 'medium'    // TamaÃ±o de fuente por defecto
            ];
            $configModel->create($configData);
    
            // Generar token de activaciÃ³n y enviarlo por email
            $activationToken = bin2hex(random_bytes(16));
            $userModel->setActivationToken($userId, $activationToken);
    
            // Construir el link de activaciÃ³n
            $activationLink = "https://" . $_SERVER['HTTP_HOST'] . "/activate.php?token=" . $activationToken;
    
            // Enviar email de activaciÃ³n
            $subject = "Activa tu cuenta";
            $body = \App\Mail\Templates\ActivationEmail::getBody($username, $activationLink);
            $emailSender = new \App\Mail\EmailSender();
            $sendResult = $emailSender->sendEmail($email, $subject, $body);
            if ($sendResult === true) {
                return ['message' => 'Usuario registrado. Se enviÃ³ email de activaciÃ³n.'];
            } else {
                return ['error' => $sendResult];
            }
        }
        return ['error' => 'No se pudo registrar al usuario'];
    }

    // Login: se requiere username y password
    public function login($data)
    {
        $username = $data['username'] ?? null;
        $password = $data['password'] ?? null;

        if (!$username || !$password) {
            return ['error' => 'Faltan campos (username, password)'];
        }

        $userModel = new User();
        $user = $userModel->findByUsername($username);
        if (!$user) {
            return ['error' => 'Credenciales invÃ¡lidas (usuario no existe)'];
        }

        if (!$user['activated']) {
            return ['error' => 'La cuenta no estÃ¡ activada. Por favor, revisa tu correo para activar tu cuenta.'];
        }

        if (!empty($user['locked_until']) && strtotime($user['locked_until']) > time()) {
            $tiempoRestante = strtotime($user['locked_until']) - time();
            return ['error' => "Usuario bloqueado. Intenta de nuevo en {$tiempoRestante} seg."];
        }

        if (!password_verify($password, $user['password'])) {
            $failed = $user['failed_attempts'] + 1;
            $lockTime = $_ENV['LOCK_TIME_MINUTES']+180 ?? 15;
            $maxAttempts = $_ENV['MAX_FAILED_ATTEMPTS'] ?? 3;

            if ($failed >= $maxAttempts) {
                $lockedUntil = date('Y-m-d H:i:s', strtotime("+{$lockTime} minutes"));
                $userModel->updateFailedAttempts($user['id'], $failed, $lockedUntil);
                $userModel->setApiToken($user['id'], "");
                return ['error' => "Cuenta bloqueada. Intenta de nuevo despuÃ©s de $lockTime minutos."];
            } else {
                $userModel->updateFailedAttempts($user['id'], $failed);
                return ['error' => "Credenciales invÃ¡lidas. Intentos fallidos: $failed"];
            }
        }

        // Reseteamos los intentos fallidos
        $userModel->updateFailedAttempts($user['id'], 0, null);

        // Generar el token JWT
        $token = JwtHelper::generateToken($user['id'], $user['username'], $user['email']);

        // NUEVO: Guardar el token en la base de datos
        $userModel->setApiToken($user['id'], $token);

        // Enviar el token en la cabecera de la respuesta (opcional)
        header("Authorization: Bearer " . $token);

        return [
            'message' => 'Login correcto'
        ];
    }

    // Perfil: retorna informaciÃ³n del usuario basÃ¡ndose en el token decodificado
    public function profile($decodedToken)
    {
        return [
            'message'  => 'Perfil de usuario',
            'user_id'  => $decodedToken->id,
            'username' => $decodedToken->username,
            'email'    => $decodedToken->email
        ];
    }

    // OlvidÃ© mi contraseÃ±a: genera token de recuperaciÃ³n y envÃ­a email real
    public function forgotPassword($data)
    {
        $email = $data['email'] ?? null;
        if (!$email) {
            return ['error' => 'Falta el email'];
        }

        $userModel = new User();
        $user = $userModel->findByEmail($email);
        if (!$user) {
            return ['error' => 'No existe un usuario con ese email'];
        }

        // Generar token Ãºnico para resetear contraseÃ±a
        $resetToken = bin2hex(random_bytes(16));
        $expires = date('Y-m-d H:i:s', strtotime('+1 hour'));

        $ok = $userModel->setResetToken($user['id'], $resetToken, $expires);
        if ($ok) {
            $resetLink = "https://" . $_SERVER['HTTP_HOST'] . "/reset_password_form.php?token=" . $resetToken;
            $subject = "RecuperaciÃ³n de contraseÃ±a";
            $body = ResetPasswordEmail::getBody($user['username'], $resetLink);
            $emailSender = new EmailSender();
            $sendResult = $emailSender->sendEmail($email, $subject, $body);
            if ($sendResult === true) {
                return ['message' => 'Se generÃ³ el token de recuperaciÃ³n y se enviÃ³ el email'];
            } else {
                return ['error' => $sendResult];
            }
        }
        return ['error' => 'No se pudo generar el token'];
    }

    // Resetear contraseÃ±a: recibe el token de recuperaciÃ³n (del header Bearer) y el nuevo password
    public function resetPassword($resetToken, $newPassword)
    {
        if (!$resetToken || !$newPassword) {
            return ['error' => 'Faltan token y/o new_password'];
        }

        $userModel = new User();
        $user = $userModel->findByResetToken($resetToken);
        if (!$user) {
            return ['error' => 'Token invÃ¡lido o expirado'];
        }

        // Actualizar la contraseÃ±a
        $hash = password_hash($newPassword, PASSWORD_BCRYPT);
        $ok = $userModel->updatePassword($user['id'], $hash);

        if ($ok) {
            // Esto elimina el bloqueo al poner intentos fallidos en 0 y locked_until en NULL
            $userModel->updateFailedAttempts($user['id'], 0, null);

            // Limpiar el token de recuperaciÃ³n
            $userModel->setResetToken($user['id'], null, null);

            return ['message' => 'ContraseÃ±a actualizada con Ã©xito'];
        }
        return ['error' => 'No se pudo actualizar la contraseÃ±a'];
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: CashBoxesController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\CashBoxes;
use App\History\CashBoxesHistory;
use App\Helpers\JwtHelper;

class CashBoxesController {

    // Lista todas las cajas para el usuario autenticado
    public function listCashBoxes(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $cashBoxesModel = new CashBoxes();
        $cashBoxes = $cashBoxesModel->listAll();
        $data = ['cash_boxes' => $cashBoxes];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Obtiene una caja por su ID
    public function getCashBox(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Cash box ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $cashBoxesModel = new CashBoxes();
        $cashBox = $cashBoxesModel->findById($id);
       /* if (!$cashBox || $cashBox['user_id'] != $userId) {
            $data = ['error' => 'Cash box not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['cash_box' => $cashBox];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea una nueva caja para el usuario autenticado
    public function addCashBox(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['name'])) {
            $data = ['error' => 'Missing required field: name'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['user_id'] = $userId;
        $body['image_file_id'] = $body['image_file_id'] ?? null;
        
        $cashBoxesModel = new CashBoxes();
        $newCashBoxId = $cashBoxesModel->create($body);
        if (!$newCashBoxId) {
            $data = ['error' => 'Error creating cash box'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de CREATION
        $history = new CashBoxesHistory();
        $history->insertHistory(
            $newCashBoxId,
            $userId,
            $body['name'],
            $body['image_file_id'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Cash box created successfully', 'cash_box_id' => $newCashBoxId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza una caja
    public function updateCashBox(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Cash box ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $cashBoxesModel = new CashBoxes();
        $existingCashBox = $cashBoxesModel->findById($id);
     /*   if (!$existingCashBox || $existingCashBox['user_id'] != $userId) {
            $data = ['error' => 'Cash box not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['name'])) {
            $data = ['error' => 'Missing required field: name'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['image_file_id'] = $body['image_file_id'] ?? null;
        $updateResult = $cashBoxesModel->update($id, $body);
        if (!$updateResult) {
            $data = ['error' => 'Error updating cash box'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new CashBoxesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['name'],
            $body['image_file_id'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Cash box updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina una caja (registrando historial previo)
    public function deleteCashBox(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Cash box ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $cashBoxesModel = new CashBoxes();
        $existingCashBox = $cashBoxesModel->findById($id);
    /*    if (!$existingCashBox || $existingCashBox['user_id'] != $userId) {
            $data = ['error' => 'Cash box not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new CashBoxesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingCashBox['name'],
            $existingCashBox['image_file_id'],
            $userId,
            'DELETION'
        );
        $deleteResult = $cashBoxesModel->delete($id);
        if (!$deleteResult) {
            $data = ['error' => 'Error deleting cash box'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Cash box deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de una caja por su ID
    public function listCashBoxHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Cash box ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $cashBoxesModel = new CashBoxes();
        $cashBox = $cashBoxesModel->findById($id);
      /*  if (!$cashBox || $cashBox['user_id'] != $userId) {
            $data = ['error' => 'Cash box not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $history = new CashBoxesHistory();
        $historyRecords = $history->listHistoryByCashBoxId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: ClientsController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Clients;
use App\History\ClientsHistory;
use App\Helpers\JwtHelper;

class ClientsController {

    // Lista TODOS los clientes (sin filtrar por user_id)
    public function listClients(Request $request, Response $response, array $args): Response {
        // Verificar token del header Authorization (se usa para autenticaciÃ³n, pero no filtra por usuario)
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        
        $clientsModel = new Clients();
        $clients = $clientsModel->listAll();
        $data = ['clients' => $clients];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    // Obtiene un cliente en particular
    public function getClient(Request $request, Response $response, array $args): Response {
        $clientId = $args['id'] ?? null;
        if (!$clientId) {
            $data = ['error' => 'Client ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        
        // Verificar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        $clientsModel = new Clients();
        $client = $clientsModel->findById($clientId);
        if (!$client) {
            $data = ['error' => 'Client not found'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }

        $data = ['client' => $client];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    // Crea un nuevo cliente y registra el historial (operaciÃ³n CREATION)
    public function addClient(Request $request, Response $response, array $args): Response {
        // Verificar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: business_name, tax_id, email. Los demÃ¡s son opcionales.
        if (!isset($body['business_name']) || !isset($body['tax_id']) || !isset($body['email'])) {
            $data = ['error' => 'Missing required fields: business_name, tax_id, email'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Asignar el user_id del token
        $body['user_id'] = $userId;
        if (!isset($body['brand_file_id'])) {
            $body['brand_file_id'] = null;
        }
        if (!isset($body['phone'])) {
            $body['phone'] = '';
        }
        if (!isset($body['address'])) {
            $body['address'] = '';
        }
        
        $clientsModel = new Clients();
        $newClientId = $clientsModel->create($body);
        if (!$newClientId) {
            $data = ['error' => 'Error creating client'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar el historial de creaciÃ³n
        $history = new ClientsHistory();
        $history->insertHistory(
            $newClientId,
            $userId,
            $body['business_name'],
            $body['tax_id'],
            $body['email'],
            $body['brand_file_id'],
            $body['phone'],
            $body['address'],
            $userId,       // changed_by: quien realiza la acciÃ³n
            'CREATION'
        );
        
        $data = ['message' => 'Client created successfully', 'client_id' => $newClientId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    // Actualiza un cliente existente y registra la operaciÃ³n en el historial (UPDATE)
    public function updateClient(Request $request, Response $response, array $args): Response {
        // Verificar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        $clientId = $args['id'] ?? null;
        if (!$clientId) {
            $data = ['error' => 'Client ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        
        $clientsModel = new Clients();
        $existingClient = $clientsModel->findById($clientId);
        if (!$existingClient) {
            $data = ['error' => 'Client not found'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }

        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['business_name']) || !isset($body['tax_id']) || !isset($body['email'])) {
            $data = ['error' => 'Missing required fields: business_name, tax_id, email'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        
        $updateResult = $clientsModel->update($clientId, $body);
        if (!$updateResult) {
            $data = ['error' => 'Error updating client'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar el historial de actualizaciÃ³n
        $history = new ClientsHistory();
        $history->insertHistory(
            $clientId,
            $existingClient['user_id'],
            $body['business_name'],
            $body['tax_id'],
            $body['email'],
            isset($body['brand_file_id']) ? $body['brand_file_id'] : null,
            $body['phone'],
            $body['address'],
            $userId,
            'UPDATE'
        );
        
        $data = ['message' => 'Client updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    // Elimina un cliente y registra la operaciÃ³n en el historial (DELETION)
    public function deleteClient(Request $request, Response $response, array $args): Response {
        // Verificar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        $clientId = $args['id'] ?? null;
        if (!$clientId) {
            $data = ['error' => 'Client ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        
        $clientsModel = new Clients();
        $existingClient = $clientsModel->findById($clientId);
        if (!$existingClient) {
            $data = ['error' => 'Client not found'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }
     /*   if ($existingClient['user_id'] != $userId) {
            $data = ['error' => 'Access denied 3'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(403)->withHeader('Content-Type', 'application/json');
        }*/
        
        // Registrar el historial de eliminaciÃ³n antes de borrar
        $history = new ClientsHistory();
        $history->insertHistory(
            $clientId,
            $existingClient['user_id'],
            $existingClient['business_name'],
            $existingClient['tax_id'],
            $existingClient['email'],
            $existingClient['brand_file_id'],
            $existingClient['phone'],
            $existingClient['address'],
            $userId,
            'DELETION'
        );
        
        $deleteResult = $clientsModel->delete($clientId);
        if (!$deleteResult) {
            $data = ['error' => 'Error deleting client'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        $data = ['message' => 'Client deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
    
    // Lista el historial de un cliente especÃ­fico
    public function listClientHistory(Request $request, Response $response, array $args): Response {
        // Verificar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        $clientId = $args['id'] ?? null;
        if (!$clientId) {
            $data = ['error' => 'Client ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        
        $clientsModel = new Clients();
        $client = $clientsModel->findById($clientId);
        if (!$client) {
            $data = ['error' => 'Client not found'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }
    /*    if ($client['user_id'] != $userId) {
            $data = ['error' => 'Access denied 4'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(403)->withHeader('Content-Type', 'application/json');
        }*/
        
        $history = new ClientsHistory();
        $historyRecords = $history->listHistoryByClientId($clientId);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}





---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: ExpensesController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Expenses;
use App\History\ExpensesHistory;
use App\Helpers\JwtHelper;

class ExpensesController {

    // Lista todos los expenses para el usuario autenticado
    public function listExpenses(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $expensesModel = new Expenses();
        $expenses = $expensesModel->listAllByUser($userId);
        $data = ['expenses' => $expenses];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Obtiene un expense por su ID (verifica que pertenezca al usuario)
    public function getExpense(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Expense ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $expensesModel = new Expenses();
        $expense = $expensesModel->findById($id);
    /*    if(!$expense || $expense['user_id'] != $userId){
            $data = ['error' => 'Expense not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['expense' => $expense];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea un nuevo expense para el usuario autenticado
    public function addExpense(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: description, category, amount, invoice_number
        if (!isset($body['description'], $body['category'], $body['amount'], $body['invoice_number'])) {
            $data = ['error' => 'Missing required fields: description, category, amount, invoice_number'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['user_id'] = $userId;
        // Opcional: folder_id, attached_files, expense_date
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['attached_files'] = $body['attached_files'] ?? null;
        $body['expense_date'] = $body['expense_date'] ?? date('Y-m-d H:i:s');
        
        $expensesModel = new Expenses();
        $newExpenseId = $expensesModel->create($body);
        if(!$newExpenseId){
            $data = ['error' => 'Error creating expense'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de CREATION
        $history = new ExpensesHistory();
        $history->insertHistory(
            $newExpenseId,
            $userId,
            $body['description'],
            $body['category'],
            $body['amount'],
            $body['invoice_number'],
            $body['folder_id'],
            $body['attached_files'],
            $body['expense_date'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Expense created successfully', 'expense_id' => $newExpenseId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza un expense; verifica que pertenezca al usuario autenticado
    public function updateExpense(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Expense ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $expensesModel = new Expenses();
        $existingExpense = $expensesModel->findById($id);
    /*    if(!$existingExpense || $existingExpense['user_id'] != $userId){
            $data = ['error' => 'Expense not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['description'], $body['category'], $body['amount'], $body['invoice_number'])) {
            $data = ['error' => 'Missing required fields: description, category, amount, invoice_number'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['attached_files'] = $body['attached_files'] ?? null;
        $body['expense_date'] = $body['expense_date'] ?? date('Y-m-d H:i:s');
        $updateResult = $expensesModel->update($id, $body);
        if(!$updateResult){
            $data = ['error' => 'Error updating expense'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new ExpensesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['description'],
            $body['category'],
            $body['amount'],
            $body['invoice_number'],
            $body['folder_id'],
            $body['attached_files'],
            $body['expense_date'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Expense updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina un expense; registra historial previo
    public function deleteExpense(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Expense ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $expensesModel = new Expenses();
        $existingExpense = $expensesModel->findById($id);
    /*    if(!$existingExpense || $existingExpense['user_id'] != $userId){
            $data = ['error' => 'Expense not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new ExpensesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingExpense['description'],
            $existingExpense['category'],
            $existingExpense['amount'],
            $existingExpense['invoice_number'],
            $existingExpense['folder_id'],
            $existingExpense['attached_files'],
            $existingExpense['expense_date'],
            $userId,
            'DELETION'
        );
        $deleteResult = $expensesModel->delete($id);
        if(!$deleteResult){
            $data = ['error' => 'Error deleting expense'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Expense deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de un expense por su ID
    public function listExpenseHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Expense ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $expensesModel = new Expenses();
        $expense = $expensesModel->findById($id);
    /*    if(!$expense || $expense['user_id'] != $userId){
            $data = ['error' => 'Expense not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $history = new ExpensesHistory();
        $historyRecords = $history->listHistoryByExpenseId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: FileController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\File;
use App\Helpers\JwtHelper;

class FileController {
    // Extensiones permitidas y tamaÃ±o mÃ¡ximo de archivo (2 MB)
    private $allowedExtensions = ['jpg', 'jpeg', 'png', 'pdf', 'doc', 'docx'];
    private $maxFileSize = 2 * 1024 * 1024; // 2 MB

    public function upload(Request $request, Response $response, array $args): Response {
        // Verificar el header Authorization
        $auth = $request->getHeaderLine('Authorization');
        if (!$auth) {
            $data = ['error' => 'Falta header Authorization'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $auth);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        // Obtener los archivos subidos
        $uploadedFiles = $request->getUploadedFiles();
        if (!isset($uploadedFiles['file'])) {
            $data = ['error' => 'No se enviÃ³ ningÃºn archivo'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $file = $uploadedFiles['file'];
        // Validar el tamaÃ±o del archivo
        if ($file->getSize() > $this->maxFileSize) {
            $data = ['error' => 'El archivo excede el tamaÃ±o permitido'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar la extensiÃ³n del archivo
        $extension = strtolower(pathinfo($file->getClientFilename(), PATHINFO_EXTENSION));
        if (!in_array($extension, $this->allowedExtensions)) {
            $data = ['error' => 'ExtensiÃ³n de archivo no permitida'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Leer el contenido del archivo
        $fileData = $file->getStream()->getContents();
        $originalName = $file->getClientFilename();
        $fileType = $file->getClientMediaType();
        $fileSize = $file->getSize();
        // Obtener el ID del usuario a partir del token
        $userId = $decoded->id;
        // Subir el archivo usando el modelo File
        $fileModel = new File();
        $fileId = $fileModel->upload($userId, $originalName, $fileType, $fileSize, $fileData);
        if (!$fileId) {
            $data = ['error' => 'Error al subir el archivo'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        // Retornar la informaciÃ³n del archivo, excluyendo el contenido binario
        $fileInfo = $fileModel->getFile($fileId);
        unset($fileInfo['file_data']);
        $data = ['message' => 'Archivo subido con Ã©xito', 'file' => $fileInfo];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    public function download(Request $request, Response $response, array $args): Response {
        // Verificar el header Authorization
        $auth = $request->getHeaderLine('Authorization');
        if (!$auth) {
            $data = ['error' => 'Falta header Authorization'];
            // Limpiar el buffer de salida, si lo hubiera, para evitar contenido previo
            if (ob_get_contents()) {
                ob_clean();
            }
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $auth);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Token invÃ¡lido o expirado'];
            if (ob_get_contents()) {
                ob_clean();
            }
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        // Validar que se haya enviado el parÃ¡metro file_id
        $params = $request->getQueryParams();
        if (!isset($params['file_id'])) {
            $data = ['error' => 'Falta file_id'];
            if (ob_get_contents()) {
                ob_clean();
            }
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $fileId = $params['file_id'];
        $userId = $decoded->id;
        $fileModel = new File();
        $file = $fileModel->getFile($fileId);
        // Validar que el archivo exista y pertenezca al usuario autenticado
        if (!$file || $file['user_id'] != $userId) {
            $data = ['error' => 'Archivo no encontrado o no tienes permiso para acceder'];
            if (ob_get_contents()) {
                ob_clean();
            }
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }
        // Limpiar el buffer de salida antes de enviar el contenido binario
        if (ob_get_contents()) {
            ob_clean();
        }
        // Establecer cabeceras y retornar el contenido del archivo
        $response = $response->withHeader('Content-Type', $file['file_type'])
            ->withHeader('Content-Disposition', 'attachment; filename="' . $file['original_name'] . '"');
        $response->getBody()->write($file['file_data']);
        return $response;
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: FoldersController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Folders;
use App\History\FoldersHistory;
use App\Helpers\JwtHelper;

class FoldersController {

    // Lista todos los folders del usuario autenticado;
    // si se envÃ­a en query el parÃ¡metro client_id se filtra por ese cliente.
    // si se envÃ­a en query el parÃ¡metro parent_id se filtra por carpeta padre.
    public function listFolders(Request $request, Response $response, array $args): Response {
        // Validar token (aunque si el filtro no es por user_id, el token solo lo usas para autenticar)
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = \App\Helpers\JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
    
        $params = $request->getQueryParams();
        $foldersModel = new \App\Models\Folders();
        
        if (isset($params['parent_id'])) {
            // Listamos las subcarpetas basÃ¡ndonos solo en parent_id (sin filtrar por user_id)
            $parentId = $params['parent_id'];
            $folders = $foldersModel->listByParentId($parentId);
        } elseif (isset($params['client_id'])) {
            // En caso de que se quiera filtrar por cliente
            $clientId = $params['client_id'];
            $folders = $foldersModel->listByClientId($clientId);
        } else {
            $folders = $foldersModel->listAll();
        }
        
        $data = ['folders' => $folders];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }


    // Devuelve un folder por su ID; verifica que pertenezca al usuario autenticado.
    public function getFolder(Request $request, Response $response, array $args): Response {
        $folderId = $args['id'] ?? null;
        if (!$folderId) {
            $data = ['error' => 'Folder ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $foldersModel = new Folders();
        $folder = $foldersModel->findById($folderId);
    /*    if (!$folder || $folder['user_id'] != $userId) {
            $data = ['error' => 'Folder not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['folder' => $folder];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea un nuevo folder para el usuario autenticado.
    // Requiere: client_id y name (ademÃ¡s de otros opcionales: parent_id, folder_image_file_id).
    public function addFolder(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        
        // Obtener datos del request (se requiere client_id y name)
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['client_id']) || !isset($body['name'])) {
            $data = ['error' => 'Faltan campos requeridos: client_id y name'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $body['user_id'] = $userId;
        $body['parent_id'] = $body['parent_id'] ?? null;
        $body['folder_image_file_id'] = $body['folder_image_file_id'] ?? null;
        
        // Crear folder usando el modelo
        $foldersModel = new Folders();
        $newFolderId = $foldersModel->create($body);
        if (!$newFolderId) {
            $data = ['error' => 'Error al crear el folder'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de creaciÃ³n
        $history = new FoldersHistory();
        $history->insertHistory(
            $newFolderId,
            $userId,
            $body['client_id'],
            $body['name'],
            $body['parent_id'],
            $body['folder_image_file_id'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Folder creado exitosamente', 'folder_id' => $newFolderId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza un folder existente; se requiere que el folder pertenezca al usuario autenticado.
    public function updateFolder(Request $request, Response $response, array $args): Response {
        $folderId = $args['id'] ?? null;
        if (!$folderId) {
            $data = ['error' => 'Folder ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $foldersModel = new Folders();
        $existingFolder = $foldersModel->findById($folderId);
       /* if (!$existingFolder || $existingFolder['user_id'] != $userId) {
            $data = ['error' => 'Folder not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['name'])) {
            $data = ['error' => 'Missing required field: name'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $updateResult = $foldersModel->update($folderId, $body);
        if (!$updateResult) {
            $data = ['error' => 'Error updating folder'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new FoldersHistory();
        $history->insertHistory(
            $folderId,
            $userId,
            $existingFolder['client_id'],
            $body['name'],
            $body['parent_id'] ?? $existingFolder['parent_id'],
            $body['folder_image_file_id'] ?? $existingFolder['folder_image_file_id'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Folder updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina un folder; registra la operaciÃƒÂ³n en el historial.
    public function deleteFolder(Request $request, Response $response, array $args): Response {
        $folderId = $args['id'] ?? null;
        if (!$folderId) {
            $data = ['error' => 'Folder ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $foldersModel = new Folders();
        $existingFolder = $foldersModel->findById($folderId);
      /*  if (!$existingFolder || $existingFolder['user_id'] != $userId) {
            $data = ['error' => 'Folder not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new FoldersHistory();
        $history->insertHistory(
            $folderId,
            $userId,
            $existingFolder['client_id'],
            $existingFolder['name'],
            $existingFolder['parent_id'],
            $existingFolder['folder_image_file_id'],
            $userId,
            'DELETION'
        );
        $deleteResult = $foldersModel->delete($folderId);
        if (!$deleteResult) {
            $data = ['error' => 'Error deleting folder'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Folder deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de un folder por su ID.
    public function listFolderHistory(Request $request, Response $response, array $args): Response {
        $folderId = $args['id'] ?? null;
        if (!$folderId) {
            $data = ['error' => 'Folder ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $foldersModel = new Folders();
        $folder = $foldersModel->findById($folderId);
    /*    if (!$folder || $folder['user_id'] != $decoded->id) {
            $data = ['error' => 'Folder not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $history = new FoldersHistory();
        $historyRecords = $history->listHistoryByFolderId($folderId);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // (Opcional) Lista folders de un cliente especÃ­fico.
    public function listFoldersByClient(Request $request, Response $response, array $args): Response {
        $clientId = $args['client_id'] ?? null;
        if (!$clientId) {
            $data = ['error' => 'Client ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $foldersModel = new Folders();
        $folders = $foldersModel->listByClientId($clientId, $userId);
        $data = ['folders' => $folders];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: JobsController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Jobs;
use App\History\JobsHistory;
use App\Helpers\JwtHelper;

class JobsController {

    // Lista todos los jobs del usuario autenticado
    public function listJobs(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $jobsModel = new Jobs();
        $jobs = $jobsModel->listAll();
        $data = ['jobs' => $jobs];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Obtiene un job por su ID
    public function getJob(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Job ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $jobsModel = new Jobs();
        $job = $jobsModel->findById($id);
       /* if(!$job || $job['user_id'] != $userId){
            $data = ['error' => 'Job not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type','application/json');
        }*/
        $data = ['job' => $job];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Crea un nuevo job para el usuario autenticado
    public function addJob(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: client_id, type_of_work, description, status
       /* if (!isset($body['client_id'], $body['type_of_work'], $body['description'], $body['status'])) {
            $data = ['error' => 'Missing required fields: client_id, type_of_work, description, status'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }*/
        $body['user_id'] = $userId;
        // Opcionales: product_service_id, folder_id, start_datetime, end_datetime, multiplicative_value, attached_files
        $body['product_service_id'] = $body['product_service_id'] ?? null;
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['start_datetime'] = $body['start_datetime'] ?? null;
        $body['end_datetime'] = $body['end_datetime'] ?? null;
        $body['multiplicative_value'] = $body['multiplicative_value'] ?? 1.00;
        $body['attached_files'] = $body['attached_files'] ?? null;
        
        $jobsModel = new Jobs();
        $newJobId = $jobsModel->create($body);
        if(!$newJobId){
            $data = ['error' => 'Error creating job'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type','application/json');
        }
        
        // Registrar historial de CREATION
        $history = new JobsHistory();
        $history->insertHistory(
            $newJobId,
            $userId,
            $body['client_id'],
            $body['product_service_id'],
            $body['folder_id'],
            $body['type_of_work'],
            $body['description'],
            $body['status'],
            $body['start_datetime'],
            $body['end_datetime'],
            $body['multiplicative_value'],
            $body['attached_files'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Job created successfully', 'job_id' => $newJobId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Actualiza un job; verifica que pertenezca al usuario autenticado
    public function updateJob(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Job ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $jobsModel = new Jobs();
        $existingJob = $jobsModel->findById($id);
     /*   if(!$existingJob || $existingJob['user_id'] != $userId){
            $data = ['error' => 'Job not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type','application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['client_id'], $body['type_of_work'], $body['description'], $body['status'])) {
            $data = ['error' => 'Missing required fields: client_id, type_of_work, description, status'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }
        $body['product_service_id'] = $body['product_service_id'] ?? null;
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['start_datetime'] = $body['start_datetime'] ?? null;
        $body['end_datetime'] = $body['end_datetime'] ?? null;
        $body['multiplicative_value'] = $body['multiplicative_value'] ?? 1.00;
        $body['attached_files'] = $body['attached_files'] ?? null;
        
        $updateResult = $jobsModel->update($id, $body);
        if(!$updateResult){
            $data = ['error' => 'Error updating job'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type','application/json');
        }
        // Registrar historial de UPDATE
        $history = new JobsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['client_id'],
            $body['product_service_id'],
            $body['folder_id'],
            $body['type_of_work'],
            $body['description'],
            $body['status'],
            $body['start_datetime'],
            $body['end_datetime'],
            $body['multiplicative_value'],
            $body['attached_files'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Job updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Elimina un job, registrando historial previo
    public function deleteJob(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Job ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if(!$authHeader){
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $jobsModel = new Jobs();
        $existingJob = $jobsModel->findById($id);
      /*  if(!$existingJob || $existingJob['user_id'] != $userId){
            $data = ['error' => 'Job not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type','application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new JobsHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingJob['client_id'],
            $existingJob['product_service_id'],
            $existingJob['folder_id'],
            $existingJob['type_of_work'],
            $existingJob['description'],
            $existingJob['status'],
            $existingJob['start_datetime'],
            $existingJob['end_datetime'],
            $existingJob['multiplicative_value'],
            $existingJob['attached_files'],
            $userId,
            'DELETION'
        );
        $deleteResult = $jobsModel->delete($id);
        if(!$deleteResult){
            $data = ['error' => 'Error deleting job'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type','application/json');
        }
        $data = ['message' => 'Job deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }

    // Lista el historial de un job por su ID
    public function listJobHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if(!$id){
            $data = ['error' => 'Job ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type','application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if(!$decoded){
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type','application/json');
        }
        $userId = $decoded->id;
        $jobsModel = new Jobs();
      /*  $job = $jobsModel->findById($id);
        if(!$job || $job['user_id'] != $userId){
            $data = ['error' => 'Job not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type','application/json');
        }*/
        $history = new JobsHistory();
        $historyRecords = $history->listHistoryByJobId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type','application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: PermissionsController.php
Content:
<?php
namespace App\Controllers;

use App\Models\Permission;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class PermissionsController {

    // MÃ©todo para listar solo los permisos globales
    public function listGlobalPermissions(Request $request, Response $response, array $args): Response {
        $permissionModel = new Permission();
        $permissions = $permissionModel->listGlobal();
        $result = ['permissions' => $permissions];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // MÃ©todo para listar todos los permisos
    public function listPermissions(Request $request, Response $response, array $args): Response {
        $permissionModel = new Permission();
        $permissions = $permissionModel->listAll();
        $result = ['permissions' => $permissions];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // MÃ©todo para listar permisos filtrados por usuario (pasando el user_id por la URL)
    public function listPermissionsByUser(Request $request, Response $response, array $args): Response {
        $userId = $args['user_id'] ?? null;
        if (!$userId) {
            $result = ['error' => 'Falta el parÃ¡metro user_id'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $permissionModel = new Permission();
        $permissions = $permissionModel->listByUser($userId);
        $result = ['permissions' => $permissions];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }
            
    public function addPermission(Request $request, Response $response, array $args): Response {
        $data = json_decode($request->getBody()->getContents(), true);
        
        if (!isset($data['sector'])) {
            $result = ['error' => 'El campo sector es obligatorio'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        $permissionModel = new Permission();
        $assignedUserId = $data['user_id'] ?? null;
        
        // Verificar si ya existe el permiso para evitar duplicados
        if ($permissionModel->exists($assignedUserId, $data['sector'])) {
            $result = ['error' => 'El permiso ya existe para este usuario'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Crear el permiso
        $insertId = $permissionModel->create($data);
        
        // Obtener el token desde el header y decodificarlo para extraer el id del usuario que realiza la acciÃ³n
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = \App\Helpers\JwtHelper::verifyToken($token);
        $tokenUserId = $decoded ? $decoded->id : null;
        
        if ($insertId) {
            // Registrar en historial la operaciÃ³n de creaciÃ³n con el id extraÃ­do del token
            $permissionHistory = new \App\History\PermissionsHistory();
            $permissionHistory->insertHistory(
                $insertId,        // permissionId
                $assignedUserId,  // userId (puede ser null para permisos globales)
                $data['sector'],  // sector
                $tokenUserId,     // changedBy (ID del usuario que hace la modificaciÃ³n)
                'CREATION'        // operationType
            );
            
            $result = ['message' => 'Permiso creado exitosamente', 'permission_id' => $insertId];
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } else {
            $result = ['error' => 'Error al crear el permiso'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
    }
    
    public function deletePermission(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $result = ['error' => 'Falta el ID del permiso'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        $permissionModel = new Permission();
        
        // Obtener detalles del permiso a eliminar
        $permissionDetails = $permissionModel->getById($id);
        if (!$permissionDetails) {
            $result = ['error' => 'Permiso no encontrado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Proceder a eliminar el permiso
        $deleted = $permissionModel->delete($id);
        if ($deleted) {
            // Extraer el id del usuario que realiza la acciÃ³n desde el token
            $authHeader = $request->getHeaderLine('Authorization');
            $token = str_replace('Bearer ', '', $authHeader);
            $decoded = \App\Helpers\JwtHelper::verifyToken($token);
            $tokenUserId = $decoded ? $decoded->id : null;
            
            // Registrar en historial la operaciÃ³n de eliminaciÃ³n
            $permissionHistory = new \App\History\PermissionsHistory();
            $permissionHistory->insertHistory(
                $id,                              // permissionId
                $permissionDetails['user_id'],    // userId del permiso (puede ser null para global)
                $permissionDetails['sector'],     // sector
                $tokenUserId,                     // changedBy (ID del usuario que hace la modificaciÃ³n)
                'DELETION'                        // operationType
            );
            
            $result = ['message' => 'Permiso eliminado exitosamente'];
            $response->getBody()->write(json_encode($result));
            return $response->withHeader('Content-Type', 'application/json');
        } else {
            $result = ['error' => 'Error al eliminar el permiso'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
    }

}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: ProductsServicesController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\ProductsServices;
use App\History\ProductsServicesHistory;
use App\Helpers\JwtHelper;

class ProductsServicesController {

    // Lista todos los productos/servicios para el usuario autenticado
    public function listProductsServices(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $psModel = new ProductsServices();
        $records = $psModel->listAll();
        $data = ['products_services' => $records];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Devuelve un producto/servicio por su ID (verificando que pertenezca al usuario)
    public function getProductService(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Product/Service ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $psModel = new ProductsServices();
        $record = $psModel->findById($id);
     /*   if (!$record || $record['user_id'] != $userId) {
            $data = ['error' => 'Record not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['product_service' => $record];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea un nuevo producto/servicio para el usuario autenticado
    public function addProductService(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: description, category, price, cost, difficulty, item_type, stock
        // if (!isset($body['description'], $body['category'], $body['price'], $body['cost'], $body['difficulty'], $body['item_type'], $body['stock'])) {
        //     $data = ['error' => 'Missing required fields: description, category, price, cost, difficulty, item_type, stock'];
        //     $response->getBody()->write(json_encode($data));
        //     return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        // }
        $body['user_id'] = $userId;
        $body['product_image_file_id'] = $body['product_image_file_id'] ?? null;
        
        $psModel = new ProductsServices();
        $newId = $psModel->create($body);
        if (!$newId) {
            $data = ['error' => 'Error creating product/service'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de CREATION
        $history = new ProductsServicesHistory();
        $history->insertHistory(
            $newId,
            $userId,
            $body['description'],
            $body['category'],
            $body['price'],
            $body['cost'],
            $body['difficulty'],
            $body['item_type'],
            $body['product_image_file_id'],
            $body['stock'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Product/Service created successfully', 'id' => $newId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza un registro de producto/servicio (verificando que pertenezca al usuario)
    public function updateProductService(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Product/Service ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $psModel = new ProductsServices();
        $existing = $psModel->findById($id);
     /*   if (!$existing || $existing['user_id'] != $userId) {
            $data = ['error' => 'Record not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        // if (!isset($body['description'], $body['category'], $body['price'], $body['cost'], $body['difficulty'], $body['item_type'], $body['stock'])) {
        //     $data = ['error' => 'Missing required fields: description, category, price, cost, difficulty, item_type, stock'];
        //     $response->getBody()->write(json_encode($data));
        //     return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        // }
        $body['product_image_file_id'] = $body['product_image_file_id'] ?? null;
        $updateResult = $psModel->update($id, $body);
        if (!$updateResult) {
            $data = ['error' => 'Error updating record'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new ProductsServicesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['description'],
            $body['category'],
            $body['price'],
            $body['cost'],
            $body['difficulty'],
            $body['item_type'],
            $body['product_image_file_id'],
            $body['stock'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Record updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina un registro de producto/servicio (registrando historial previo)
    public function deleteProductService(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Product/Service ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $psModel = new ProductsServices();
        $existing = $psModel->findById($id);
    /*    if (!$existing || $existing['user_id'] != $userId) {
            $data = ['error' => 'Record not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new ProductsServicesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existing['description'],
            $existing['category'],
            $existing['price'],
            $existing['cost'],
            $existing['difficulty'],
            $existing['item_type'],
            $existing['product_image_file_id'],
            $existing['stock'],
            $userId,
            'DELETION'
        );
        $deleteResult = $psModel->delete($id);
        if (!$deleteResult) {
            $data = ['error' => 'Error deleting record'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Record deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de un producto/servicio por su ID
    public function listProductServiceHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Product/Service ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $psModel = new ProductsServices();
        $record = $psModel->findById($id);
       /* if (!$record || $record['user_id'] != $userId) {
            $data = ['error' => 'Record not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }*/
        $history = new ProductsServicesHistory();
        $historyRecords = $history->listHistoryByProductServiceId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: ProfileController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Helpers\JwtHelper;

class ProfileController {
    public function getProfile(Request $request, Response $response, array $args): Response {
        // Limpiar el buffer de salida para evitar contenido previo
        if (ob_get_contents()) {
            ob_clean();
        }

        // Verificar el header Authorization y validar el token
        $auth = $request->getHeaderLine('Authorization');
        if (!$auth) {
            $data = ['error' => 'Falta header Authorization'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $auth);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        // Si el token tiene el claim "exp", formatearlo a una fecha legible
        $expiration = isset($decoded->exp) ? date('Y-m-d H:i:s', $decoded->exp) : 'N/A';
        
        // Retornar la informaciÃ³n del usuario y la expiraciÃ³n de la sesiÃ³n
        $data = [
            'user' => $decoded,
            'session_expires' => $expiration
        ];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: ProfilesListController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Helpers\JwtHelper;
use App\Models\User;

class ProfilesListController {
    public function listAllProfiles(Request $request, Response $response, array $args): Response {
        // Limpiar el buffer de salida para evitar contenido previo
        if (ob_get_contents()) {
            ob_clean();
        }

        // Obtener el token, si se envÃ­a, y decodificarlo para obtener el ID del usuario actual
        $auth = $request->getHeaderLine('Authorization');
        $currentUserId = null;
        if ($auth) {
            $token = str_replace('Bearer ', '', $auth);
            $decoded = JwtHelper::verifyToken($token);
            if ($decoded && isset($decoded->id)) {
                $currentUserId = $decoded->id;
            }
        }

        // Instanciar el modelo y obtener los perfiles
        $userModel = new User();
        $profiles = $userModel->getAllProfiles();

        // Filtrar para que no se incluya el perfil del usuario actual
        if ($currentUserId !== null) {
            $profiles = array_filter($profiles, function($profile) use ($currentUserId) {
                return $profile['id'] != $currentUserId;
            });
        }

        // Reindexar el array para devolver una lista limpia
        $data = ['profiles' => array_values($profiles)];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: SalesController.php
Content:
<?php
namespace App\Controllers;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use App\Models\Sales;
use App\History\SalesHistory;
use App\Helpers\JwtHelper;

class SalesController {

    // Lista todas las ventas para el usuario autenticado
    public function listSales(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $salesModel = new Sales();
        $sales = $salesModel->listAllByUser($userId);
        $data = ['sales' => $sales];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Obtiene una venta por su ID (verificando que pertenezca al usuario)
    public function getSale(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Sale ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $salesModel = new Sales();
        $sale = $salesModel->findById($id);
    /*    if (!$sale || $sale['user_id'] != $userId) {
            $data = ['error' => 'Sale not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $data = ['sale' => $sale];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Crea una nueva venta para el usuario autenticado
    public function addSale(Request $request, Response $response, array $args): Response {
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $body = json_decode($request->getBody()->getContents(), true);
        // Campos requeridos: client_id, product_service_id, invoice_number, amount
        if (!isset($body['client_id'], $body['product_service_id'], $body['invoice_number'], $body['amount'])) {
            $data = ['error' => 'Missing required fields: client_id, product_service_id, invoice_number, amount'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['user_id'] = $userId;
        // Opcionales:
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['sale_date'] = $body['sale_date'] ?? date('Y-m-d H:i:s');
        $body['attached_files'] = $body['attached_files'] ?? null;
        
        $salesModel = new Sales();
        $newSaleId = $salesModel->create($body);
        if (!$newSaleId) {
            $data = ['error' => 'Error creating sale'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Registrar historial de CREATION
        $history = new SalesHistory();
        $history->insertHistory(
            $newSaleId,
            $userId,
            $body['client_id'],
            $body['product_service_id'],
            $body['folder_id'],
            $body['invoice_number'],
            $body['amount'],
            $body['sale_date'],
            $body['attached_files'],
            $userId,
            'CREATION'
        );
        
        $data = ['message' => 'Sale created successfully', 'sale_id' => $newSaleId];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Actualiza una venta; verifica que pertenezca al usuario autenticado
    public function updateSale(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Sale ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $salesModel = new Sales();
        $existingSale = $salesModel->findById($id);
    /*    if (!$existingSale || $existingSale['user_id'] != $userId) {
            $data = ['error' => 'Sale not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $body = json_decode($request->getBody()->getContents(), true);
        if (!isset($body['client_id'], $body['product_service_id'], $body['invoice_number'], $body['amount'])) {
            $data = ['error' => 'Missing required fields: client_id, product_service_id, invoice_number, amount'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $body['folder_id'] = $body['folder_id'] ?? null;
        $body['sale_date'] = $body['sale_date'] ?? date('Y-m-d H:i:s');
        $body['attached_files'] = $body['attached_files'] ?? null;
        $updateResult = $salesModel->update($id, $body);
        if (!$updateResult) {
            $data = ['error' => 'Error updating sale'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial de UPDATE
        $history = new SalesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $body['client_id'],
            $body['product_service_id'],
            $body['folder_id'],
            $body['invoice_number'],
            $body['amount'],
            $body['sale_date'],
            $body['attached_files'],
            $userId,
            'UPDATE'
        );
        $data = ['message' => 'Sale updated successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Elimina una venta (registrando historial previo)
    public function deleteSale(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Sale ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            $data = ['error' => 'Authorization header missing'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $salesModel = new Sales();
        $existingSale = $salesModel->findById($id);
   /*     if (!$existingSale || $existingSale['user_id'] != $userId) {
            $data = ['error' => 'Sale not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        // Registrar historial de DELETION antes de eliminar
        $history = new SalesHistory();
        $history->insertHistory(
            $id,
            $userId,
            $existingSale['client_id'],
            $existingSale['product_service_id'],
            $existingSale['folder_id'],
            $existingSale['invoice_number'],
            $existingSale['amount'],
            $existingSale['sale_date'],
            $existingSale['attached_files'],
            $userId,
            'DELETION'
        );
        $deleteResult = $salesModel->delete($id);
        if (!$deleteResult) {
            $data = ['error' => 'Error deleting sale'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = ['message' => 'Sale deleted successfully'];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // Lista el historial de una venta por su ID
    public function listSaleHistory(Request $request, Response $response, array $args): Response {
        $id = $args['id'] ?? null;
        if (!$id) {
            $data = ['error' => 'Sale ID required'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $data = ['error' => 'Invalid or expired token'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $salesModel = new Sales();
        $sale = $salesModel->findById($id);
    /*    if (!$sale || $sale['user_id'] != $userId) {
            $data = ['error' => 'Sale not found or access denied'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }*/
        $history = new SalesHistory();
        $historyRecords = $history->listHistoryBySaleId($id);
        $data = ['history' => $historyRecords];
        $response->getBody()->write(json_encode($data));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: UserConfigurationsController.php
Content:
<?php
namespace App\Controllers;

use App\Models\UserConfigurations;
use App\History\UserConfigurationsHistory;
use App\Helpers\JwtHelper;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class UserConfigurationsController {
    
    public function myConfigurations(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Obtiene la configuraciÃ³n del usuario autenticado
        $userId = $decoded->id;
        $configModel = new UserConfigurations();
        $configuration = $configModel->findByUserId($userId);
        
        if (!$configuration) {
            $result = ['error' => 'ConfiguraciÃ³n no encontrada'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        $response->getBody()->write(json_encode(['configuration' => $configuration]));
        return $response->withHeader('Content-Type', 'application/json');
    }


    // GET /user_configurations -> Lista todas las configuraciones (sin restricciÃ³n)
    public function listConfigurations(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader || !JwtHelper::verifyToken(str_replace('Bearer ', '', $authHeader))) {
            $data = ['error' => 'Token invÃ¡lido o ausente'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $configModel = new UserConfigurations();
        $configs = $configModel->listAll();
        $response->getBody()->write(json_encode(['configurations' => $configs]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // GET /user_configurations/{id} -> Devuelve la configuraciÃ³n especÃ­fica (sin restricciÃ³n de propietario)
    public function getConfiguration(Request $request, Response $response, array $args): Response {
        $configId = $args['id'] ?? null;
        if (!$configId) {
            $data = ['error' => 'Falta el ID de la configuraciÃ³n'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader || !JwtHelper::verifyToken(str_replace('Bearer ', '', $authHeader))) {
            $data = ['error' => 'Token invÃ¡lido o ausente'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $configModel = new UserConfigurations();
        $config = $configModel->findByUserId($configId);
        if (!$config) {
            $data = ['error' => 'ConfiguraciÃ³n no encontrada'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $response->getBody()->write(json_encode(['configuration' => $config]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // POST /user_configurations -> Crea la configuraciÃ³n para el usuario autenticado
    public function addConfiguration(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = json_decode($request->getBody()->getContents(), true);
        if (!isset($data['role'], $data['view_type'], $data['theme'], $data['font_size'])) {
            $result = ['error' => 'Faltan campos requeridos: role, view_type, theme, font_size'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $data['user_id'] = $userId;
        $configModel = new UserConfigurations();
        if ($configModel->findByUserId($userId)) {
            $result = ['error' => 'Ya existe una configuraciÃ³n para este usuario'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $newConfigId = $configModel->create($data);
        if (!$newConfigId) {
            $result = ['error' => 'Error al crear la configuraciÃ³n'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserConfigurationsHistory();
        $history->insertHistory(
            $newConfigId,
            $userId,
            $data['role'],
            $data['view_type'],
            $data['theme'],
            $data['font_size'],
            $userId,
            'CREATION'
        );
        $result = ['message' => 'ConfiguraciÃ³n creada exitosamente', 'configuration_id' => $newConfigId];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // PUT /user_configurations -> Actualiza la configuraciÃ³n del usuario autenticado
    public function updateConfiguration(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = json_decode($request->getBody()->getContents(), true);
        if (!isset($data['role'], $data['view_type'], $data['theme'], $data['font_size'])) {
            $result = ['error' => 'Faltan campos requeridos: role, view_type, theme, font_size'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $configModel = new UserConfigurations();
        $existingConfig = $configModel->findByUserId($userId);
        if (!$existingConfig) {
            $result = ['error' => 'ConfiguraciÃ³n no encontrada'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $updateResult = $configModel->update($existingConfig['id'], $data);
        if (!$updateResult) {
            $result = ['error' => 'Error al actualizar la configuraciÃ³n'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserConfigurationsHistory();
        $history->insertHistory(
            $existingConfig['id'],
            $userId,
            $data['role'],
            $data['view_type'],
            $data['theme'],
            $data['font_size'],
            $userId,
            'UPDATE'
        );
        $result = ['message' => 'ConfiguraciÃ³n actualizada exitosamente'];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // DELETE /user_configurations -> Elimina la configuraciÃ³n del usuario autenticado
    public function deleteConfiguration(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $configModel = new UserConfigurations();
        $existingConfig = $configModel->findByUserId($userId);
        if (!$existingConfig) {
            $result = ['error' => 'ConfiguraciÃ³n no encontrada'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $deleteResult = $configModel->delete($existingConfig['id']);
        if (!$deleteResult) {
            $result = ['error' => 'Error al eliminar la configuraciÃ³n'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserConfigurationsHistory();
        $history->insertHistory(
            $existingConfig['id'],
            $userId,
            $existingConfig['role'],
            $existingConfig['view_type'],
            $existingConfig['theme'],
            $existingConfig['font_size'],
            $userId,
            'DELETION'
        );
        $result = ['message' => 'ConfiguraciÃ³n eliminada exitosamente'];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Controllers
File: UserProfileController.php
Content:
<?php
namespace App\Controllers;

use App\Models\UserProfile;
use App\History\UserProfileHistory;
use App\Helpers\JwtHelper;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class UserProfileController {
    
    public function myProfile(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        // Obtiene el perfil del usuario autenticado
        $userId = $decoded->id;
        $profileModel = new UserProfile();
        $profile = $profileModel->findByUserId($userId);
        
        if (!$profile) {
            $result = ['error' => 'Perfil no encontrado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        
        $response->getBody()->write(json_encode(['profile' => $profile]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // GET /user_profile -> Lista todos los perfiles (sin restricciÃ³n)
    public function listProfiles(Request $request, Response $response, array $args): Response {
        // Se requiere token vÃ¡lido (aunque la consulta sea libre)
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader || !JwtHelper::verifyToken(str_replace('Bearer ', '', $authHeader))) {
            $data = ['error' => 'Token invÃ¡lido o ausente'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $profileModel = new UserProfile();
        $profiles = $profileModel->listAll();
        $response->getBody()->write(json_encode(['profiles' => $profiles]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // GET /user_profile/{id} -> Devuelve el perfil especÃ­fico (sin restricciÃ³n de propietario)
    public function getProfile(Request $request, Response $response, array $args): Response {
        $profileId = $args['id'] ?? null;
        if (!$profileId) {
            $data = ['error' => 'Falta el ID del perfil'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Se requiere token vÃ¡lido
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader || !JwtHelper::verifyToken(str_replace('Bearer ', '', $authHeader))) {
            $data = ['error' => 'Token invÃ¡lido o ausente'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $profileModel = new UserProfile();
        $profile = $profileModel->findByUserId($profileId);
        if (!$profile) {
            $data = ['error' => 'Perfil no encontrado'];
            $response->getBody()->write(json_encode($data));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $response->getBody()->write(json_encode(['profile' => $profile]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // POST /user_profile -> Crea el perfil para el usuario autenticado (se toma el ID del token)
    public function addProfile(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = json_decode($request->getBody()->getContents(), true);
        if (empty($data['full_name'])) {
            $result = ['error' => 'El campo full_name es obligatorio'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $profileModel = new UserProfile();
        if ($profileModel->findByUserId($userId)) {
            $result = ['error' => 'Ya existe un perfil para este usuario'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data['user_id'] = $userId;
        $newProfileId = $profileModel->create($data);
        if (!$newProfileId) {
            $result = ['error' => 'Error al crear el perfil'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserProfileHistory();
        $history->insertHistory(
            $newProfileId,
            $userId,
            $data['full_name'],
            $data['phone'] ?? '',
            $data['address'] ?? '',
            $data['cuit'] ?? '',
            $data['profile_file_id'] ?? null,
            $userId,
            'CREATION'
        );
        $result = ['message' => 'Perfil creado exitosamente', 'profile_id' => $newProfileId];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // PUT /user_profile -> Actualiza el perfil del usuario autenticado (se toma el ID del token)
    public function updateProfile(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $data = json_decode($request->getBody()->getContents(), true);
        if (empty($data['full_name'])) {
            $result = ['error' => 'El campo full_name es obligatorio'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(400)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $profileModel = new UserProfile();
        $existingProfile = $profileModel->findByUserId($userId);
        if (!$existingProfile) {
            $result = ['error' => 'Perfil no encontrado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $updateResult = $profileModel->update($existingProfile['id'], $data);
        if (!$updateResult) {
            $result = ['error' => 'Error al actualizar el perfil'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserProfileHistory();
        $history->insertHistory(
            $existingProfile['id'],
            $userId,
            $data['full_name'],
            $data['phone'] ?? '',
            $data['address'] ?? '',
            $data['cuit'] ?? '',
            $data['profile_file_id'] ?? null,
            $userId,
            'UPDATE'
        );
        $result = ['message' => 'Perfil actualizado exitosamente'];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }

    // DELETE /user_profile -> Elimina el perfil del usuario autenticado (se toma el ID del token)
    public function deleteProfile(Request $request, Response $response, array $args): Response {
        // Validar token
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            $result = ['error' => 'Token invÃ¡lido o expirado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(401)
                            ->withHeader('Content-Type', 'application/json');
        }
        $userId = $decoded->id;
        $profileModel = new UserProfile();
        $existingProfile = $profileModel->findByUserId($userId);
        if (!$existingProfile) {
            $result = ['error' => 'Perfil no encontrado'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(404)
                            ->withHeader('Content-Type', 'application/json');
        }
        $deleteResult = $profileModel->delete($existingProfile['id']);
        if (!$deleteResult) {
            $result = ['error' => 'Error al eliminar el perfil'];
            $response->getBody()->write(json_encode($result));
            return $response->withStatus(500)
                            ->withHeader('Content-Type', 'application/json');
        }
        // Registrar historial
        $history = new UserProfileHistory();
        $history->insertHistory(
            $existingProfile['id'],
            $userId,
            $existingProfile['full_name'],
            $existingProfile['phone'],
            $existingProfile['address'],
            $existingProfile['cuit'],
            $existingProfile['profile_file_id'],
            $userId,
            'DELETION'
        );
        $result = ['message' => 'Perfil eliminado exitosamente'];
        $response->getBody()->write(json_encode($result));
        return $response->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Helpers
File: JwtHelper.php
Content:
<?php
namespace App\Helpers;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

class JwtHelper
{
    public static function generateToken($userId, $username, $email)
    {
        $secretKey = $_ENV['JWT_SECRET'] ?? 'fallbackSecret';
        $payload = [
            'iss'      => 'mi_sistema',
            'iat'      => time(),
            'exp'      => time() + 3600,  // Token vÃ¡lido por xx segundos
            'id'       => $userId,
            'username' => $username,
            'email'    => $email
        ];
        return JWT::encode($payload, $secretKey, 'HS256');
    }

    public static function verifyToken($token)
    {
        $secretKey = $_ENV['JWT_SECRET'] ?? 'fallbackSecret';
        try {
            $decoded = JWT::decode($token, new Key($secretKey, 'HS256'));
            return $decoded;
        } catch (\Exception $e) {
            return null;
        }
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: AccountingClosingsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class AccountingClosingsHistory {
    private $conn;
    private $table = 'accounting_closings_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de cierres contables.
     *
     * ParÃ¡metros:
     * - closing_id: ID del cierre afectado.
     * - user_id: ID del dueÃ±o.
     * - cash_box_id: ID de la caja de efectivo asociada.
     * - closing_date: Fecha del cierre.
     * - final_balance: Saldo final.
     * - total_income: Total de ingresos.
     * - total_expenses: Total de egresos.
     * - comments: Comentarios (opcional).
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($closing_id, $user_id, $cash_box_id, $closing_date, $final_balance, $total_income, $total_expenses, $comments, $changed_by, $operation_type) {
        $sql = "INSERT INTO {$this->table}
                (closing_id, user_id, cash_box_id, closing_date, final_balance, total_income, total_expenses, comments, changed_by, operation_type)
                VALUES (:closing_id, :user_id, :cash_box_id, :closing_date, :final_balance, :total_income, :total_expenses, :comments, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':closing_id', $closing_id, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $user_id, PDO::PARAM_INT);
        $stmt->bindParam(':cash_box_id', $cash_box_id, PDO::PARAM_INT);
        $stmt->bindParam(':closing_date', $closing_date);
        $stmt->bindParam(':final_balance', $final_balance);
        $stmt->bindParam(':total_income', $total_income);
        $stmt->bindParam(':total_expenses', $total_expenses);
        $comments = isset($comments) ? $comments : null;
        $stmt->bindParam(':comments', $comments);
        $stmt->bindParam(':changed_by', $changed_by, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operation_type);
        return $stmt->execute();
    }

    // Lista el historial de un cierre contable por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryByClosingId($closing_id) {
        $sql = "SELECT * FROM {$this->table} WHERE closing_id = :closing_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':closing_id', $closing_id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: AppointmentsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class AppointmentsHistory {
    private $conn;
    private $table = 'appointments_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de appointments.
     *
     * ParÃ¡metros:
     * - appointment_id: ID del appointment afectado.
     * - user_id: ID del dueÃ±o.
     * - client_id: ID del cliente.
     * - job_id: ID del job asociado (opcional).
     * - appointment_date: Fecha de la cita.
     * - appointment_time: Hora de la cita.
     * - location: UbicaciÃ³n de la cita.
     * - site_image_file_id: ID de la imagen del sitio (opcional).
     * - attached_files: Archivos adjuntos (opcional).
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($appointment_id, $user_id, $client_id, $job_id, $appointment_date, $appointment_time, $location, $site_image_file_id, $attached_files, $changed_by, $operation_type) {
        $sql = "INSERT INTO {$this->table}
                (appointment_id, user_id, client_id, job_id, appointment_date, appointment_time, location, site_image_file_id, attached_files, changed_by, operation_type)
                VALUES (:appointment_id, :user_id, :client_id, :job_id, :appointment_date, :appointment_time, :location, :site_image_file_id, :attached_files, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':appointment_id', $appointment_id, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $user_id, PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $client_id, PDO::PARAM_INT);
        $job_id = isset($job_id) ? $job_id : null;
        $stmt->bindParam(':job_id', $job_id);
        $stmt->bindParam(':appointment_date', $appointment_date);
        $stmt->bindParam(':appointment_time', $appointment_time);
        $stmt->bindParam(':location', $location);
        $siteImageFileId = isset($site_image_file_id) ? $site_image_file_id : null;
        $stmt->bindParam(':site_image_file_id', $siteImageFileId);
        $attached_files = isset($attached_files) ? $attached_files : null;
        $stmt->bindParam(':attached_files', $attached_files);
        $stmt->bindParam(':changed_by', $changed_by, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operation_type);
        return $stmt->execute();
    }

    // Lista el historial de un appointment por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryByAppointmentId($appointment_id) {
        $sql = "SELECT * FROM {$this->table} WHERE appointment_id = :appointment_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':appointment_id', $appointment_id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: CashBoxesHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class CashBoxesHistory {
    private $conn;
    private $table = 'cash_boxes_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de cash_boxes.
     *
     * ParÃ¡metros:
     * - cash_box_id: ID de la caja afectada.
     * - user_id: ID del dueÃ±o de la caja.
     * - name: nombre de la caja.
     * - image_file_id: ID de la imagen asociada (opcional).
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($cashBoxId, $userId, $name, $imageFileId, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table}
                (cash_box_id, user_id, name, image_file_id, changed_by, operation_type)
                VALUES (:cash_box_id, :user_id, :name, :image_file_id, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':cash_box_id', $cashBoxId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':name', $name);
        $stmt->bindParam(':image_file_id', $imageFileId);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }

    // Lista el historial de una caja por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryByCashBoxId($cashBoxId) {
        $sql = "SELECT * FROM {$this->table} WHERE cash_box_id = :cash_box_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':cash_box_id', $cashBoxId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: ClientsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class ClientsHistory {
    private $conn;
    private $table = 'clients_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Inserta un registro en el historial de clientes
    // ParÃ¡metros: 
    //   client_id: ID del cliente afectado
    //   user_id: ID del usuario dueÃ±o del cliente
    //   business_name, tax_id, email, brand_file_id, phone, address: datos actuales del cliente
    //   changed_by: ID del usuario que realizÃ³ el cambio (normalmente el mismo)
    //   operation_type: 'CREATION', 'UPDATE' o 'DELETION'
    public function insertHistory($clientId, $userId, $businessName, $taxId, $email, $brandFileId, $phone, $address, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table} 
                (client_id, user_id, business_name, tax_id, email, brand_file_id, phone, address, changed_by, operation_type)
                VALUES (:client_id, :user_id, :business_name, :tax_id, :email, :brand_file_id, :phone, :address, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $clientId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':business_name', $businessName);
        $stmt->bindParam(':tax_id', $taxId);
        $stmt->bindParam(':email', $email);
        $brandFileId = isset($brandFileId) ? $brandFileId : null;
        $stmt->bindParam(':brand_file_id', $brandFileId, PDO::PARAM_INT);
        $stmt->bindParam(':phone', $phone);
        $stmt->bindParam(':address', $address);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }
    
    // Lista todos los registros de historial de un cliente, ordenados por fecha de cambio descendente
    public function listHistoryByClientId($clientId) {
        $sql = "SELECT * FROM {$this->table} WHERE client_id = :client_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $clientId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: ExpensesHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class ExpensesHistory {
    private $conn;
    private $table = 'expenses_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de expenses.
     *
     * ParÃ¡metros:
     * - expense_id: ID del expense afectado.
     * - user_id: ID del dueÃ±o.
     * - description: DescripciÃ³n del expense.
     * - category: CategorÃ­a.
     * - amount: Monto.
     * - invoice_number: NÃºmero de factura.
     * - folder_id: ID del folder (opcional).
     * - attached_files: Archivos adjuntos (opcional).
     * - expense_date: Fecha del expense.
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($expense_id, $user_id, $description, $category, $amount, $invoice_number, $folder_id, $attached_files, $expense_date, $changed_by, $operation_type) {
        $sql = "INSERT INTO {$this->table}
                (expense_id, user_id, description, category, amount, invoice_number, folder_id, attached_files, expense_date, changed_by, operation_type)
                VALUES (:expense_id, :user_id, :description, :category, :amount, :invoice_number, :folder_id, :attached_files, :expense_date, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':expense_id', $expense_id, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $user_id, PDO::PARAM_INT);
        $stmt->bindParam(':description', $description);
        $stmt->bindParam(':category', $category);
        $stmt->bindParam(':amount', $amount);
        $stmt->bindParam(':invoice_number', $invoice_number);
        $folder_id = isset($folder_id) ? $folder_id : null;
        $stmt->bindParam(':folder_id', $folder_id);
        $attached_files = isset($attached_files) ? $attached_files : null;
        $stmt->bindParam(':attached_files', $attached_files);
        $stmt->bindParam(':expense_date', $expense_date);
        $stmt->bindParam(':changed_by', $changed_by, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operation_type);
        return $stmt->execute();
    }

    // Lista el historial de un expense por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryByExpenseId($expense_id) {
        $sql = "SELECT * FROM {$this->table} WHERE expense_id = :expense_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':expense_id', $expense_id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: FoldersHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class FoldersHistory {
    private $conn;
    private $table = 'folders_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de folders.
     *
     * ParÃ¡metros:
     * - folder_id: ID del folder afectado
     * - user_id: ID del dueÃ±o del folder
     * - client_id: ID del cliente al que pertenece el folder
     * - name: nombre actual del folder
     * - parent_id: ID del folder padre (si existe)
     * - folder_image_file_id: ID de la imagen asociada (opcional)
     * - changed_by: ID del usuario que realizÃ³ el cambio
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'
     */
    public function insertHistory($folderId, $userId, $clientId, $name, $parentId, $folderImageFileId, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table} 
                (folder_id, user_id, client_id, name, parent_id, folder_image_file_id, changed_by, operation_type)
                VALUES (:folder_id, :user_id, :client_id, :name, :parent_id, :folder_image_file_id, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':folder_id', $folderId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $clientId, PDO::PARAM_INT);
        $stmt->bindParam(':name', $name);
        $stmt->bindParam(':parent_id', $parentId);
        $stmt->bindParam(':folder_image_file_id', $folderImageFileId);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }
    
    // Lista el historial de un folder por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo.
    public function listHistoryByFolderId($folderId) {
        $sql = "SELECT * FROM {$this->table} WHERE folder_id = :folder_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':folder_id', $folderId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: JobsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class JobsHistory {
    private $conn;
    private $table = 'jobs_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de jobs.
     *
     * ParÃ¡metros:
     * - job_id: ID del job afectado.
     * - user_id: ID del dueÃ±o.
     * - client_id: ID del cliente.
     * - product_service_id: ID del producto/servicio asociado (puede ser NULL).
     * - folder_id: ID del folder (puede ser NULL).
     * - type_of_work: Tipo de trabajo.
     * - description: DescripciÃ³n del job.
     * - status: Estado del job.
     * - start_datetime: Fecha y hora de inicio (puede ser NULL).
     * - end_datetime: Fecha y hora de finalizaciÃ³n (puede ser NULL).
     * - multiplicative_value: Valor multiplicador (por defecto 1.00).
     * - attached_files: Archivos adjuntos (opcional).
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($job_id, $user_id, $client_id, $product_service_id, $folder_id, $type_of_work, $description, $status, $start_datetime, $end_datetime, $multiplicative_value, $attached_files, $changed_by, $operation_type) {
        $sql = "INSERT INTO {$this->table}
                (job_id, user_id, client_id, product_service_id, folder_id, type_of_work, description, status, start_datetime, end_datetime, multiplicative_value, attached_files, changed_by, operation_type)
                VALUES (:job_id, :user_id, :client_id, :product_service_id, :folder_id, :type_of_work, :description, :status, :start_datetime, :end_datetime, :multiplicative_value, :attached_files, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':job_id', $job_id, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $user_id, PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $client_id, PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $product_service_id, PDO::PARAM_INT);
        $folder_id = isset($folder_id) ? $folder_id : null;
        $stmt->bindParam(':folder_id', $folder_id);
        $stmt->bindParam(':type_of_work', $type_of_work);
        $stmt->bindParam(':description', $description);
        $stmt->bindParam(':status', $status);
        $stmt->bindParam(':start_datetime', $start_datetime);
        $stmt->bindParam(':end_datetime', $end_datetime);
        $stmt->bindParam(':multiplicative_value', $multiplicative_value);
        $attached_files = isset($attached_files) ? $attached_files : null;
        $stmt->bindParam(':attached_files', $attached_files);
        $stmt->bindParam(':changed_by', $changed_by, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operation_type);
        return $stmt->execute();
    }

    // Lista el historial de un job por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryByJobId($job_id) {
        $sql = "SELECT * FROM {$this->table} WHERE job_id = :job_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':job_id', $job_id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: PermissionsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class PermissionsHistory {
    private $conn;
    private $table = 'permissions_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de permisos.
     *
     * @param int    $permissionId  ID del permiso afectado.
     * @param int|null $userId      ID del usuario asociado al permiso (puede ser NULL).
     * @param string $sector        Sector del permiso.
     * @param int    $changedBy     ID del usuario que realizÃ³ la acciÃ³n.
     * @param string $operationType Tipo de operaciÃ³n: 'CREATION', 'DELETION', etc.
     */
    public function insertHistory($permissionId, $userId, $sector, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table} 
                (permission_id, user_id, sector, changed_by, operation_type)
                VALUES (:permission_id, :user_id, :sector, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':permission_id', $permissionId, PDO::PARAM_INT);
        if ($userId === null) {
            $stmt->bindValue(':user_id', null, PDO::PARAM_NULL);
        } else {
            $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        }
        $stmt->bindParam(':sector', $sector);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: ProductsServicesHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class ProductsServicesHistory {
    private $conn;
    private $table = 'products_services_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de productos/servicios.
     *
     * ParÃ¡metros:
     * - ps_id: ID del producto/servicio afectado.
     * - user_id: ID del dueÃ±o.
     * - description: descripciÃ³n actual.
     * - category: categorÃ­a.
     * - price: precio.
     * - cost: costo.
     * - difficulty: dificultad.
     * - item_type: 'product' o 'service'.
     * - product_image_file_id: ID de la imagen asociada (opcional).
     * - stock: cantidad de stock.
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($psId, $userId, $description, $category, $price, $cost, $difficulty, $itemType, $productImageFileId, $stock, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table}
                (ps_id, user_id, description, category, price, cost, difficulty, item_type, product_image_file_id, stock, changed_by, operation_type)
                VALUES (:ps_id, :user_id, :description, :category, :price, :cost, :difficulty, :item_type, :product_image_file_id, :stock, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':ps_id', $psId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':description', $description);
        $stmt->bindParam(':category', $category);
        $stmt->bindParam(':price', $price);
        $stmt->bindParam(':cost', $cost);
        $stmt->bindParam(':difficulty', $difficulty);
        $stmt->bindParam(':item_type', $itemType);
        $productImageFileId = isset($productImageFileId) ? $productImageFileId : null;
        $stmt->bindParam(':product_image_file_id', $productImageFileId);
        $stmt->bindParam(':stock', $stock);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }

    // Lista el historial de un producto/servicio por su ID (ps_id)
    public function listHistoryByProductServiceId($psId) {
        $sql = "SELECT * FROM {$this->table} WHERE ps_id = :ps_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':ps_id', $psId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: SalesHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class SalesHistory {
    private $conn;
    private $table = 'sales_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de ventas.
     *
     * ParÃ¡metros:
     * - sale_id: ID de la venta afectada.
     * - user_id: ID del dueÃ±o de la venta.
     * - client_id: ID del cliente.
     * - product_service_id: ID del producto o servicio vendido.
     * - folder_id: ID del folder (si se relaciona) o NULL.
     * - invoice_number: NÃºmero de factura.
     * - amount: Monto de la venta.
     * - sale_date: Fecha de la venta.
     * - attached_files: Archivos adjuntos (opcional).
     * - changed_by: ID del usuario que realizÃ³ la operaciÃ³n.
     * - operation_type: 'CREATION', 'UPDATE' o 'DELETION'.
     */
    public function insertHistory($saleId, $userId, $clientId, $productServiceId, $folderId, $invoiceNumber, $amount, $saleDate, $attachedFiles, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table}
                (sale_id, user_id, client_id, product_service_id, folder_id, invoice_number, amount, sale_date, attached_files, changed_by, operation_type)
                VALUES (:sale_id, :user_id, :client_id, :product_service_id, :folder_id, :invoice_number, :amount, :sale_date, :attached_files, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':sale_id', $saleId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $clientId, PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $productServiceId, PDO::PARAM_INT);
        $folderId = isset($folderId) ? $folderId : null;
        $stmt->bindParam(':folder_id', $folderId);
        $stmt->bindParam(':invoice_number', $invoiceNumber);
        $stmt->bindParam(':amount', $amount);
        $stmt->bindParam(':sale_date', $saleDate);
        $attachedFiles = isset($attachedFiles) ? $attachedFiles : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }

    // Lista el historial de una venta por su ID, ordenado de mÃ¡s reciente a mÃ¡s antiguo
    public function listHistoryBySaleId($saleId) {
        $sql = "SELECT * FROM {$this->table} WHERE sale_id = :sale_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':sale_id', $saleId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: UserConfigurationsHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class UserConfigurationsHistory {
    private $conn;
    private $table = 'user_configurations_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de configuraciones.
     */
    public function insertHistory($configId, $userId, $role, $viewType, $theme, $fontSize, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table} 
                (config_id, user_id, role, view_type, theme, font_size, changed_by, operation_type)
                VALUES (:config_id, :user_id, :role, :view_type, :theme, :font_size, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':config_id', $configId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':role', $role);
        $stmt->bindParam(':view_type', $viewType);
        $stmt->bindParam(':theme', $theme);
        $stmt->bindParam(':font_size', $fontSize);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }
    
    /**
     * Lista el historial de una configuraciÃ³n por su ID.
     */
    public function listHistoryByConfigId($configId) {
        $sql = "SELECT * FROM {$this->table} WHERE config_id = :config_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':config_id', $configId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\History
File: UserProfileHistory.php
Content:
<?php
namespace App\History;

use App\Config\Database;
use PDO;

class UserProfileHistory {
    private $conn;
    private $table = 'user_profile_history';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro en el historial de perfiles.
     */
    public function insertHistory($profileId, $userId, $fullName, $phone, $address, $cuit, $profileFileId, $changedBy, $operationType) {
        $sql = "INSERT INTO {$this->table} 
                (profile_id, user_id, full_name, phone, address, cuit, profile_file_id, changed_by, operation_type)
                VALUES (:profile_id, :user_id, :full_name, :phone, :address, :cuit, :profile_file_id, :changed_by, :operation_type)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':profile_id', $profileId, PDO::PARAM_INT);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':full_name', $fullName);
        $stmt->bindParam(':phone', $phone);
        $stmt->bindParam(':address', $address);
        $stmt->bindParam(':cuit', $cuit);
        $profileFileId = isset($profileFileId) ? $profileFileId : null;
        $stmt->bindParam(':profile_file_id', $profileFileId, PDO::PARAM_INT);
        $stmt->bindParam(':changed_by', $changedBy, PDO::PARAM_INT);
        $stmt->bindParam(':operation_type', $operationType);
        return $stmt->execute();
    }
    
    /**
     * Lista el historial de un perfil por su ID.
     */
    public function listHistoryByProfileId($profileId) {
        $sql = "SELECT * FROM {$this->table} WHERE profile_id = :profile_id ORDER BY changed_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':profile_id', $profileId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Mail
File: EmailSender.php
Content:
<?php
namespace App\Mail;

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;

class EmailSender {
    private $mailer;

    public function __construct() {
        $this->mailer = new PHPMailer(true);
        // ConfiguraciÃ³n SMTP
        $this->mailer->isSMTP();
        $this->mailer->Host       = $_ENV['SMTP_HOST'] ?? 'smtp.example.com';
        $this->mailer->SMTPAuth   = true;
        $this->mailer->Username   = $_ENV['SMTP_USER'] ?? 'user@example.com';
        $this->mailer->Password   = $_ENV['SMTP_PASS'] ?? 'password';
        $this->mailer->SMTPSecure = $_ENV['SMTP_SECURE'] ?? 'tls';
        $this->mailer->Port       = $_ENV['SMTP_PORT'] ?? 587;
        $this->mailer->CharSet    = 'UTF-8';
    }

    public function sendEmail($to, $subject, $body) {
        try {
            $this->mailer->setFrom($_ENV['SMTP_FROM'] ?? 'noreply@example.com', $_ENV['SMTP_FROM_NAME'] ?? 'Sistema');
            $this->mailer->addAddress($to);
            $this->mailer->Subject = $subject;
            $this->mailer->Body    = $body;
            $this->mailer->isHTML(true);
            $this->mailer->send();
            return true;
        } catch (Exception $e) {
            return 'Mailer Error: ' . $this->mailer->ErrorInfo;
        }
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Mail\Templates
File: ActivationEmail.php
Content:
<?php
namespace App\Mail\Templates;

class ActivationEmail {
    /**
     * Retorna el cuerpo del email para activar la cuenta.
     *
     * @param string $username
     * @param string $activationLink
     * @return string HTML del email
     */
    public static function getBody($username, $activationLink) {
        return "
            <html>
            <head>
                <meta charset='UTF-8'>
                <title>Activa tu cuenta</title>
            </head>
            <body>
                <p>Hola {$username},</p>
                <p>Gracias por registrarte. Para activar tu cuenta, por favor haz clic en el siguiente enlace:</p>
                <p><a href='{$activationLink}'>Activar Cuenta</a></p>
                <p>Si no te registraste en nuestro sistema, ignora este mensaje.</p>
            </body>
            </html>
        ";
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Mail\Templates
File: ResetPasswordEmail.php
Content:
<?php
namespace App\Mail\Templates;

class ResetPasswordEmail {
    /**
     * Retorna el cuerpo del email para restablecer la contraseÃ±a.
     *
     * @param string $username
     * @param string $resetLink
     * @return string HTML del email
     */
    public static function getBody($username, $resetLink) {
        return "
            <html>
            <head>
                <meta charset='UTF-8'>
                <title>Resetear ContraseÃ±a</title>
            </head>
            <body>
                <p>Hola {$username},</p>
                <p>Recibimos una solicitud para restablecer tu contraseÃ±a.</p>
                <p>Por favor, haz clic en el siguiente enlace para acceder a la pÃ¡gina donde podrÃ¡s ingresar tu nueva contraseÃ±a de forma segura:</p>
                <p><a href='{$resetLink}'>Restablecer ContraseÃ±a</a></p>
                <p>Si no solicitaste este cambio, ignora este mensaje.</p>
            </body>
            </html>
        ";
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Middleware
File: ActivityLogMiddleware.php
Content:
<?php
namespace App\Middleware;

use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Server\RequestHandlerInterface;
use App\Helpers\JwtHelper;
use App\Models\ActivityLog;

class ActivityLogMiddleware
{
    public function __invoke(Request $request, RequestHandlerInterface $handler): Response
    {
        // Primero procesamos la peticiÃ³n
        $response = $handler->handle($request);

        // Obtener info de la request
        $ipAddress = $request->getServerParams()['REMOTE_ADDR'] ?? 'unknown';
        $userAgent = $request->getHeaderLine('User-Agent') ?: 'unknown';
        $method    = $request->getMethod();
        $route     = (string) $request->getUri()->getPath();

        // Intentar decodificar el token (para obtener user_id si existe)
        $userId = null;
        $authHeader = $request->getHeaderLine('Authorization');
        if ($authHeader) {
            $token = str_replace('Bearer ', '', $authHeader);
            $decoded = JwtHelper::verifyToken($token);
            if ($decoded && isset($decoded->id)) {
                $userId = $decoded->id;
            }
        }

        // Obtener info de la respuesta
        $statusCode = $response->getStatusCode();

        // Opcional: capturar el body final para ver si hay error o mensaje
        $bodyContent = (string) $response->getBody();

        // Guardar en tabla activity_log
        $log = new ActivityLog();
        $log->insert(
            $userId,
            $route,
            $method,
            $ipAddress,
            $userAgent,
            $statusCode,
            $bodyContent
        );

        // Retornar la respuesta al cliente
        return $response;
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Middleware
File: AuthMiddleware.php
Content:
<?php
// Archivo: src/Middleware/AuthMiddleware.php

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

class AuthMiddleware
{
    public function __invoke(Request $request, $handler): Response
    {
        $authHeader = $request->getHeaderLine('Authorization');

        if (!$authHeader) {
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode(['error' => 'No se proporcionÃ³ token']));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }

        // Se asume el formato "Bearer token..."
        $token = str_replace('Bearer ', '', $authHeader);

        try {
            // Decodificar el token utilizando la clave secreta del archivo .env
            $decoded = JWT::decode($token, new Key($_ENV['JWT_SECRET'], 'HS256'));
        } catch (\Exception $e) {
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode(['error' => 'Token invÃ¡lido']));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }

        // Se asume que el token contiene el ID del usuario en 'user_id'
        $userId = $decoded->user_id ?? null;
        if (!$userId) {
            $response = new \Slim\Psr7\Response();
            $response->getBody()->write(json_encode(['error' => 'Token sin informaciÃ³n de usuario']));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }

        // Realizar consulta a la base de datos para obtener el usuario (ejemplo)
        $user = $this->getUserFromDb($userId);

        // Verificar si el usuario estÃ¡ bloqueado
        if ($user && isset($user['locked_until'])) {
            $lockedUntil = new \DateTime($user['locked_until']);
            $now = new \DateTime();
            if ($lockedUntil > $now) {
                $response = new \Slim\Psr7\Response();
                $response->getBody()->write(json_encode(['error' => 'El usuario estÃ¡ bloqueado']));
                return $response->withStatus(403)->withHeader('Content-Type', 'application/json');
            }
        }

        // Puedes aÃ±adir el usuario a los atributos de la solicitud para usarlo en los controladores
        $request = $request->withAttribute('user', $user);

        return $handler->handle($request);
    }

    /**
     * FunciÃ³n simulada para obtener un usuario de la base de datos.
     * En un caso real, se deberÃ­a utilizar un modelo o capa de acceso a datos.
     */
    private function getUserFromDb($userId)
    {
        // Ejemplo simulado; reemplaza con consulta real
        // Supongamos que $user contiene un array con datos del usuario
        // Ejemplo:
        // [
        //    'id' => 1,
        //    'username' => 'usuario1',
        //    'locked_until' => '2025-03-03 12:00:00'
        // ]
        
        // AquÃ­ deberÃ­as conectar a la base de datos y obtener la informaciÃ³n
        // Para este ejemplo, simulamos que el usuario con id 1 estÃ¡ bloqueado hasta el futuro
        if ($userId == 1) {
            return [
                'id' => 1,
                'username' => 'usuario1',
                'locked_until' => '2099-01-01 00:00:00' // bloqueado indefinidamente para la demo
            ];
        }
        
        // Para otros usuarios, asumimos que no estÃ¡n bloqueados
        return [
            'id' => $userId,
            'username' => 'usuario' . $userId,
            'locked_until' => null
        ];
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Middleware
File: CheckUserBlockedMiddleware.php
Content:
<?php
namespace App\Middleware;

use App\Models\User;
use App\Helpers\JwtHelper;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class CheckUserBlockedMiddleware
{
    public function __invoke(Request $request, RequestHandlerInterface $handler): ResponseInterface
    {
        // Creamos una instancia de la fÃ¡brica de respuestas.
        $responseFactory = new ResponseFactory();

        // Obtener el token del header Authorization
        $authHeader = $request->getHeaderLine('Authorization');
        $token = str_replace('Bearer ', '', $authHeader);

        if (!$token) {
            return $this->jsonResponse(
                $responseFactory->createResponse(),
                'Token no proporcionado',
                401
            );
        }

        // Decodificar el token para obtener el user_id
        $decodedToken = JwtHelper::verifyToken($token);
        if (!$decodedToken) {
            return $this->jsonResponse(
                $responseFactory->createResponse(),
                'Token invÃ¡lido',
                401
            );
        }

        // Buscar al usuario en la base de datos
        $userModel = new User();
        $user = $userModel->findById($decodedToken->id);

        // Verificar que el token recibido coincida con el token guardado
        if ($user && isset($user['api_token']) && $user['api_token'] !== $token) {
            return $this->jsonResponse(
                $responseFactory->createResponse(),
                'El token no coincide con el almacenado en la base de datos',
                403
            );
        }

        // Verificar si el usuario estÃ¡ bloqueado
        if ($user && $user['locked_until'] !== null && strtotime($user['locked_until']) > time()) {
            return $this->jsonResponse(
                $responseFactory->createResponse(),
                'Usuario bloqueado',
                403
            );
        }

        // Si pasa todas las validaciones, continuamos el flujo normal
        return $handler->handle($request);
    }

    /**
     * Retorna una respuesta JSON con el status y mensaje indicados.
     */
    private function jsonResponse(ResponseInterface $response, string $message, int $statusCode): ResponseInterface
    {
        $response->getBody()->write(json_encode(['error' => $message], JSON_UNESCAPED_UNICODE));
        return $response
            ->withStatus($statusCode)
            ->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Middleware
File: PermissionsMiddleware.php
Content:
<?php
namespace App\Middleware;

use App\Models\Permission;
use App\Helpers\JwtHelper;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\RequestHandlerInterface;
use Slim\Psr7\Factory\ResponseFactory;

class PermissionsMiddleware {
    private $requiredPermission;

    public function __construct(string $requiredPermission) {
        $this->requiredPermission = $requiredPermission;
    }

    public function __invoke(Request $request, RequestHandlerInterface $handler): ResponseInterface {
        $responseFactory = new ResponseFactory();

        // Obtener token de Authorization
        $authHeader = $request->getHeaderLine('Authorization');
        if (!$authHeader) {
            return $this->jsonResponse($responseFactory->createResponse(), 'Falta header Authorization', 401);
        }
        $token = str_replace('Bearer ', '', $authHeader);
        $decoded = JwtHelper::verifyToken($token);
        if (!$decoded) {
            return $this->jsonResponse($responseFactory->createResponse(), 'Token invÃ¡lido o expirado', 401);
        }
        // Si el usuario es superadmin (id=1), permitir sin restricciones
        if (isset($decoded->id) && $decoded->id == 1) {
            return $handler->handle($request);
        }

        // Verificar permiso en la base de datos
        $permissionModel = new Permission();
        if ($permissionModel->hasPermission($decoded->id, $this->requiredPermission)) {
            return $handler->handle($request);
        } else {
            return $this->jsonResponse($responseFactory->createResponse(), 'Acceso denegado: permiso insuficiente', 403);
        }
    }

    private function jsonResponse(ResponseInterface $response, string $message, int $statusCode): ResponseInterface {
        $response->getBody()->write(json_encode(['error' => $message], JSON_UNESCAPED_UNICODE));
        return $response->withStatus($statusCode)->withHeader('Content-Type', 'application/json');
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: AccountingClosings.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class AccountingClosings {
    private $conn;
    private $table = 'accounting_closings';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo registro de cierre contable y retorna su ID
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table}
                (user_id, cash_box_id, closing_date, final_balance, total_income, total_expenses, comments)
                VALUES (:user_id, :cash_box_id, :closing_date, :final_balance, :total_income, :total_expenses, :comments)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':cash_box_id', $data['cash_box_id'], PDO::PARAM_INT);
        $stmt->bindParam(':closing_date', $data['closing_date']);
        $stmt->bindParam(':final_balance', $data['final_balance']);
        $stmt->bindParam(':total_income', $data['total_income']);
        $stmt->bindParam(':total_expenses', $data['total_expenses']);
        $comments = isset($data['comments']) ? $data['comments'] : null;
        $stmt->bindParam(':comments', $comments);
        if ($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene un cierre contable por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Lista todos los cierres contables para un usuario
    public function listAllByUser($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza un cierre contable
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    cash_box_id = :cash_box_id,
                    closing_date = :closing_date,
                    final_balance = :final_balance,
                    total_income = :total_income,
                    total_expenses = :total_expenses,
                    comments = :comments,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':cash_box_id', $data['cash_box_id'], PDO::PARAM_INT);
        $stmt->bindParam(':closing_date', $data['closing_date']);
        $stmt->bindParam(':final_balance', $data['final_balance']);
        $stmt->bindParam(':total_income', $data['total_income']);
        $stmt->bindParam(':total_expenses', $data['total_expenses']);
        $comments = isset($data['comments']) ? $data['comments'] : null;
        $stmt->bindParam(':comments', $comments);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }

    // Elimina un cierre contable por su ID
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: ActivityLog.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class ActivityLog
{
    private $conn;
    private $table = 'activity_log';

    public function __construct()
    {
        $db = new Database();
        $this->conn = $db->connect();
    }

    /**
     * Inserta un registro de actividad en la tabla activity_log.
     *
     * @param int|null $userId      ID de usuario o null si no hay usuario logueado.
     * @param string   $route       Ruta/endpoint accedido.
     * @param string   $method      MÃ©todo HTTP (GET, POST, etc.).
     * @param string   $ipAddress   IP del cliente.
     * @param string   $userAgent   Agente de usuario (navegador/cliente).
     * @param int      $statusCode  CÃ³digo de estado de la respuesta.
     * @param string   $message     Texto libre con informaciÃ³n adicional (ej: error, success, etc.).
     */
    public function insert($userId, $route, $method, $ipAddress, $userAgent, $statusCode, $message = '')
    {
        $sql = "INSERT INTO {$this->table}
                (user_id, route, method, ip_address, user_agent, status_code, message)
                VALUES (:user_id, :route, :method, :ip_address, :user_agent, :status_code, :message)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId);
        $stmt->bindParam(':route', $route);
        $stmt->bindParam(':method', $method);
        $stmt->bindParam(':ip_address', $ipAddress);
        $stmt->bindParam(':user_agent', $userAgent);
        $stmt->bindParam(':status_code', $statusCode);
        $stmt->bindParam(':message', $message);
        $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Appointments.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Appointments {
    private $conn;
    private $table = 'appointments';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo appointment y retorna el ID insertado
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, client_id, job_id, appointment_date, appointment_time, location, site_image_file_id, attached_files)
                VALUES (:user_id, :client_id, :job_id, :appointment_date, :appointment_time, :location, :site_image_file_id, :attached_files)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $jobId = isset($data['job_id']) ? $data['job_id'] : null;
        $stmt->bindParam(':job_id', $jobId);
        $stmt->bindParam(':appointment_date', $data['appointment_date']);
        $stmt->bindParam(':appointment_time', $data['appointment_time']);
        $stmt->bindParam(':location', $data['location']);
        $siteImageFileId = isset($data['site_image_file_id']) ? $data['site_image_file_id'] : null;
        $stmt->bindParam(':site_image_file_id', $siteImageFileId);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene un appointment por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todos los appointments para un usuario
    public function listAllByUser($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Actualiza un appointment
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    client_id = :client_id,
                    job_id = :job_id,
                    appointment_date = :appointment_date,
                    appointment_time = :appointment_time,
                    location = :location,
                    site_image_file_id = :site_image_file_id,
                    attached_files = :attached_files,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $jobId = isset($data['job_id']) ? $data['job_id'] : null;
        $stmt->bindParam(':job_id', $jobId);
        $stmt->bindParam(':appointment_date', $data['appointment_date']);
        $stmt->bindParam(':appointment_time', $data['appointment_time']);
        $stmt->bindParam(':location', $data['location']);
        $siteImageFileId = isset($data['site_image_file_id']) ? $data['site_image_file_id'] : null;
        $stmt->bindParam(':site_image_file_id', $siteImageFileId);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina un appointment por su ID
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: CashBoxes.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class CashBoxes {
    private $conn;
    private $table = 'cash_boxes';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea una nueva caja de efectivo y retorna su ID
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} (user_id, name, image_file_id)
                VALUES (:user_id, :name, :image_file_id)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':name', $data['name']);
        $imageFileId = isset($data['image_file_id']) ? $data['image_file_id'] : null;
        $stmt->bindParam(':image_file_id', $imageFileId);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene una caja por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todas las cajas del usuario
  /*  public function listAllByUser($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }*/
    
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    
    // Actualiza una caja
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET name = :name, image_file_id = :image_file_id, updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':name', $data['name']);
        $imageFileId = isset($data['image_file_id']) ? $data['image_file_id'] : null;
        $stmt->bindParam(':image_file_id', $imageFileId);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina una caja
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Clients.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Clients {
    private $conn;
    private $table = 'clients';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo cliente
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, business_name, tax_id, email, brand_file_id, phone, address)
                VALUES (:user_id, :business_name, :tax_id, :email, :brand_file_id, :phone, :address)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':business_name', $data['business_name']);
        $stmt->bindParam(':tax_id', $data['tax_id']);
        $stmt->bindParam(':email', $data['email']);
        $brandFileId = isset($data['brand_file_id']) ? $data['brand_file_id'] : null;
        $stmt->bindParam(':brand_file_id', $brandFileId, PDO::PARAM_INT);
        $stmt->bindParam(':phone', $data['phone']);
        $stmt->bindParam(':address', $data['address']);
        if ($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Retorna un cliente por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todos los clientes (sin filtrar por user_id)
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Actualiza los datos de un cliente
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    business_name = :business_name,
                    tax_id = :tax_id,
                    email = :email,
                    brand_file_id = :brand_file_id,
                    phone = :phone,
                    address = :address,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':business_name', $data['business_name']);
        $stmt->bindParam(':tax_id', $data['tax_id']);
        $stmt->bindParam(':email', $data['email']);
        $brandFileId = isset($data['brand_file_id']) ? $data['brand_file_id'] : null;
        $stmt->bindParam(':brand_file_id', $brandFileId, PDO::PARAM_INT);
        $stmt->bindParam(':phone', $data['phone']);
        $stmt->bindParam(':address', $data['address']);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina un cliente de forma fÃ­sica
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Expenses.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Expenses {
    private $conn;
    private $table = 'expenses';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo registro de expense y retorna el ID insertado
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, description, category, amount, invoice_number, folder_id, attached_files, expense_date)
                VALUES (:user_id, :description, :category, :amount, :invoice_number, :folder_id, :attached_files, :expense_date)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':category', $data['category']);
        $stmt->bindParam(':amount', $data['amount']);
        $stmt->bindParam(':invoice_number', $data['invoice_number']);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        // Si no se especifica expense_date, se usa la fecha actual
        $expenseDate = isset($data['expense_date']) ? $data['expense_date'] : date('Y-m-d H:i:s');
        $stmt->bindParam(':expense_date', $expenseDate);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene un expense por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Lista todos los expenses pertenecientes al usuario
    public function listAllByUser($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza un expense
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    description = :description,
                    category = :category,
                    amount = :amount,
                    invoice_number = :invoice_number,
                    folder_id = :folder_id,
                    attached_files = :attached_files,
                    expense_date = :expense_date,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':category', $data['category']);
        $stmt->bindParam(':amount', $data['amount']);
        $stmt->bindParam(':invoice_number', $data['invoice_number']);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        $expenseDate = isset($data['expense_date']) ? $data['expense_date'] : date('Y-m-d H:i:s');
        $stmt->bindParam(':expense_date', $expenseDate);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }

    // Elimina un expense por su ID
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: File.php
Content:
<?php

namespace App\Models;

use App\Config\Database;  // Esto es clave

use PDO;

class File {
    private $conn;
    private $table = 'files';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Inserta un archivo en la base de datos y devuelve el ID insertado
    public function upload($userId, $originalName, $fileType, $fileSize, $fileData) {
        $sql = "INSERT INTO {$this->table} (user_id, original_name, file_type, file_size, file_data) 
                VALUES (:user_id, :original_name, :file_type, :file_size, :file_data)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':original_name', $originalName);
        $stmt->bindParam(':file_type', $fileType);
        $stmt->bindParam(':file_size', $fileSize, PDO::PARAM_INT);
        $stmt->bindParam(':file_data', $fileData, PDO::PARAM_LOB);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene la informaciÃ³n (sin el archivo binario) del archivo almacenado
    public function getFile($fileId)
    {
        $database = new Database();
        $pdo = $database->connect();
        
        $stmt = $pdo->prepare("
            SELECT id, user_id, original_name, file_type, file_size, file_data
            FROM files 
            WHERE id = ?
        ");
        $stmt->execute([$fileId]);

        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Folders.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Folders {
    private $conn;
    private $table = 'folders';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo folder y devuelve el ID insertado.
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, client_id, name, parent_id, folder_image_file_id)
                VALUES (:user_id, :client_id, :name, :parent_id, :folder_image_file_id)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $stmt->bindParam(':name', $data['name']);
        $parentId = isset($data['parent_id']) ? $data['parent_id'] : null;
        $stmt->bindParam(':parent_id', $parentId);
        $folderImageFileId = isset($data['folder_image_file_id']) ? $data['folder_image_file_id'] : null;
        $stmt->bindParam(':folder_image_file_id', $folderImageFileId);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Devuelve la informaciÃ³n de un folder por su ID.
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todos los folders pertenecientes al usuario.
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Lista los folders de un cliente especÃ­fico y que pertenezcan al usuario.
    public function listByClientId($clientId) {
        $sql = "SELECT * FROM {$this->table} WHERE client_id = :client_id AND parent_id IS NULL";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $clientId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function listByParentId($parentId) {
        $sql = "SELECT * FROM {$this->table} WHERE parent_id = :parent_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':parent_id', $parentId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza los datos de un folder.
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    name = :name,
                    parent_id = :parent_id,
                    folder_image_file_id = :folder_image_file_id,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':name', $data['name']);
        $parentId = isset($data['parent_id']) ? $data['parent_id'] : null;
        $stmt->bindParam(':parent_id', $parentId);
        $folderImageFileId = isset($data['folder_image_file_id']) ? $data['folder_image_file_id'] : null;
        $stmt->bindParam(':folder_image_file_id', $folderImageFileId);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina un folder por su ID.
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Jobs.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Jobs {
    private $conn;
    private $table = 'jobs';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo registro de job y retorna el ID insertado
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, client_id, product_service_id, folder_id, type_of_work, description, status, start_datetime, end_datetime, multiplicative_value, attached_files)
                VALUES (:user_id, :client_id, :product_service_id, :folder_id, :type_of_work, :description, :status, :start_datetime, :end_datetime, :multiplicative_value, :attached_files)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $data['product_service_id'], PDO::PARAM_INT);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $stmt->bindParam(':type_of_work', $data['type_of_work']);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':status', $data['status']);
        $startDatetime = isset($data['start_datetime']) ? $data['start_datetime'] : null;
        $stmt->bindParam(':start_datetime', $startDatetime);
        $endDatetime = isset($data['end_datetime']) ? $data['end_datetime'] : null;
        $stmt->bindParam(':end_datetime', $endDatetime);
        $multiplicativeValue = isset($data['multiplicative_value']) ? $data['multiplicative_value'] : 1.00;
        $stmt->bindParam(':multiplicative_value', $multiplicativeValue);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene un registro de job por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todos los jobs de un usuario
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Actualiza un job
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    client_id = :client_id,
                    product_service_id = :product_service_id,
                    folder_id = :folder_id,
                    type_of_work = :type_of_work,
                    description = :description,
                    status = :status,
                    start_datetime = :start_datetime,
                    end_datetime = :end_datetime,
                    multiplicative_value = :multiplicative_value,
                    attached_files = :attached_files,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $data['product_service_id'], PDO::PARAM_INT);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $stmt->bindParam(':type_of_work', $data['type_of_work']);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':status', $data['status']);
        $startDatetime = isset($data['start_datetime']) ? $data['start_datetime'] : null;
        $stmt->bindParam(':start_datetime', $startDatetime);
        $endDatetime = isset($data['end_datetime']) ? $data['end_datetime'] : null;
        $stmt->bindParam(':end_datetime', $endDatetime);
        $multiplicativeValue = isset($data['multiplicative_value']) ? $data['multiplicative_value'] : 1.00;
        $stmt->bindParam(':multiplicative_value', $multiplicativeValue);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina un job por su ID
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Permission.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Permission {
    private $conn;
    private $table = 'permissions';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Lista solo los permisos globales (user_id IS NULL)
    public function listGlobal() {
        $sql = "SELECT * FROM {$this->table} WHERE user_id IS NULL ORDER BY created_at DESC";
        $stmt = $this->conn->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Lista todos los permisos
    public function listAll() {
        $sql = "SELECT * FROM {$this->table} ORDER BY created_at DESC";
        $stmt = $this->conn->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Lista los permisos para un usuario especÃ­fico (incluyendo los permisos globales: user_id IS NULL)
    public function listByUser($userId) {
        $sql = "SELECT * FROM {$this->table} 
                WHERE user_id = :user_id
                ORDER BY created_at DESC";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function getById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Inserta un nuevo permiso
    public function create(array $data) {
        // Verificar si ya existe el permiso para ese usuario y sector
        $userId = isset($data['user_id']) ? $data['user_id'] : null;
        if ($this->exists($userId, $data['sector'])) {
            // Si ya existe, no se inserta y se retorna false.
            return false;
        }
        
        $sql = "INSERT INTO {$this->table} (user_id, sector)
                VALUES (:user_id, :sector)";
        $stmt = $this->conn->prepare($sql);
        // Si user_id es null, se enlaza correctamente con PDO::PARAM_NULL
        if ($userId === null) {
            $stmt->bindValue(':user_id', null, \PDO::PARAM_NULL);
        } else {
            $stmt->bindValue(':user_id', $userId, \PDO::PARAM_INT);
        }
        $stmt->bindParam(':sector', $data['sector']);
        if ($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }


    // Consulta si existe un permiso para un sector y un usuario (o para todos)
    public function hasPermission($userId, $sector) {
        $sql = "SELECT * FROM {$this->table} 
                WHERE sector = :sector AND (user_id = :user_id OR user_id IS NULL) 
                LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':sector', $sector);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC) !== false;
    }

    // MÃ©todo para eliminar un permiso
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    public function exists($userId, $sector) {
        $sql = "SELECT COUNT(*) FROM {$this->table} 
                WHERE sector = :sector AND ((user_id = :user_id) OR (user_id IS NULL AND :user_id IS NULL))";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':sector', $sector);
        $stmt->bindParam(':user_id', $userId);
        $stmt->execute();
        return $stmt->fetchColumn() > 0;
    }



}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: ProductsServices.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class ProductsServices {
    private $conn;
    private $table = 'products_services';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo producto/servicio y retorna su ID
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, description, category, price, cost, difficulty, item_type, product_image_file_id, stock)
                VALUES (:user_id, :description, :category, :price, :cost, :difficulty, :item_type, :product_image_file_id, :stock)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':category', $data['category']);
        $stmt->bindParam(':price', $data['price']);
        $stmt->bindParam(':cost', $data['cost']);
        $stmt->bindParam(':difficulty', $data['difficulty']);
        $stmt->bindParam(':item_type', $data['item_type']);
        $productImageFileId = isset($data['product_image_file_id']) ? $data['product_image_file_id'] : null;
        $stmt->bindParam(':product_image_file_id', $productImageFileId);
        $stmt->bindParam(':stock', $data['stock']);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Devuelve un producto/servicio por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Lista todos los productos/servicios del usuario autenticado
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza un registro de producto/servicio
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    description = :description,
                    category = :category,
                    price = :price,
                    cost = :cost,
                    difficulty = :difficulty,
                    item_type = :item_type,
                    product_image_file_id = :product_image_file_id,
                    stock = :stock,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':description', $data['description']);
        $stmt->bindParam(':category', $data['category']);
        $stmt->bindParam(':price', $data['price']);
        $stmt->bindParam(':cost', $data['cost']);
        $stmt->bindParam(':difficulty', $data['difficulty']);
        $stmt->bindParam(':item_type', $data['item_type']);
        $productImageFileId = isset($data['product_image_file_id']) ? $data['product_image_file_id'] : null;
        $stmt->bindParam(':product_image_file_id', $productImageFileId);
        $stmt->bindParam(':stock', $data['stock']);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }

    // Elimina un producto/servicio
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: Sales.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class Sales {
    private $conn;
    private $table = 'sales';

    public function __construct(){
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea una nueva venta y retorna el ID insertado
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} 
                (user_id, client_id, product_service_id, folder_id, invoice_number, amount, sale_date, attached_files)
                VALUES (:user_id, :client_id, :product_service_id, :folder_id, :invoice_number, :amount, :sale_date, :attached_files)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $data['product_service_id'], PDO::PARAM_INT);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $stmt->bindParam(':invoice_number', $data['invoice_number']);
        $stmt->bindParam(':amount', $data['amount']);
        // Si se envÃ­a la fecha de venta, se usa; de lo contrario se usa la fecha actual
        $saleDate = isset($data['sale_date']) ? $data['sale_date'] : date('Y-m-d H:i:s');
        $stmt->bindParam(':sale_date', $saleDate);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        if($stmt->execute()){
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Devuelve una venta por su ID
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todas las ventas para el usuario autenticado
    public function listAllByUser($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    // Actualiza una venta
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    client_id = :client_id,
                    product_service_id = :product_service_id,
                    folder_id = :folder_id,
                    invoice_number = :invoice_number,
                    amount = :amount,
                    sale_date = :sale_date,
                    attached_files = :attached_files,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':client_id', $data['client_id'], PDO::PARAM_INT);
        $stmt->bindParam(':product_service_id', $data['product_service_id'], PDO::PARAM_INT);
        $folderId = isset($data['folder_id']) ? $data['folder_id'] : null;
        $stmt->bindParam(':folder_id', $folderId);
        $stmt->bindParam(':invoice_number', $data['invoice_number']);
        $stmt->bindParam(':amount', $data['amount']);
        $saleDate = isset($data['sale_date']) ? $data['sale_date'] : date('Y-m-d H:i:s');
        $stmt->bindParam(':sale_date', $saleDate);
        $attachedFiles = isset($data['attached_files']) ? $data['attached_files'] : null;
        $stmt->bindParam(':attached_files', $attachedFiles);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
    
    // Elimina una venta
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: User.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class User
{
    private $conn;
    private $table = 'users';

    public function __construct()
    {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crear usuario: requiere username, email y password hash
    public function createUser($username, $email, $passwordHash)
    {
        $sql = "INSERT INTO {$this->table} (username, email, password, activated) VALUES (:username, :email, :pass, 0)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':username', $username);
        $stmt->bindParam(':email', $email);
        $stmt->bindParam(':pass', $passwordHash);
        return $stmt->execute();
    }

    public function getLastInsertId()
    {
        return $this->conn->lastInsertId();
    }

    // Buscar usuario por id
    public function findById($userId)
    {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $userId);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    // Buscar usuario por email
    public function findByEmail($email)
    {
        $sql = "SELECT * FROM {$this->table} WHERE email = :email LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':email', $email);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Buscar usuario por username
    public function findByUsername($username)
    {
        $sql = "SELECT * FROM {$this->table} WHERE username = :username LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':username', $username);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // Actualizar intentos fallidos
    public function updateFailedAttempts($userId, $failedAttempts, $lockedUntil = null)
    {
        $sql = "UPDATE {$this->table} SET failed_attempts = :failed, locked_until = :locked WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':failed', $failedAttempts);
        $stmt->bindParam(':locked', $lockedUntil);
        $stmt->bindParam(':id', $userId);
        return $stmt->execute();
    }

    // Actualizar contraseÃ±a
    public function updatePassword($userId, $newHash)
    {
        $sql = "UPDATE {$this->table} SET password = :pass WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':pass', $newHash);
        $stmt->bindParam(':id', $userId);
        return $stmt->execute();
    }

    // Guardar token de reseteo
    public function setResetToken($userId, $token, $expires)
    {
        $sql = "UPDATE {$this->table} SET password_reset_token = :token, password_reset_expires = :expires WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $token);
        $stmt->bindParam(':expires', $expires);
        $stmt->bindParam(':id', $userId);
        return $stmt->execute();
    }

    // Buscar usuario por token de reseteo
    public function findByResetToken($token)
    {
        $sql = "SELECT * FROM {$this->table} WHERE password_reset_token = :token AND password_reset_expires > NOW() LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $token);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // MÃ©todos para activaciÃ³n de cuenta (asegÃºrate de que la tabla tenga las columnas activation_token y activated)
    public function setActivationToken($userId, $token)
    {
        $sql = "UPDATE {$this->table} SET activation_token = :token, activated = 0 WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $token);
        $stmt->bindParam(':id', $userId);
        return $stmt->execute();
    }

    public function activateUser($token)
    {
        $sql = "UPDATE {$this->table} SET activated = 1, activation_token = NULL WHERE activation_token = :token";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $token);
        return $stmt->execute();
    }

    public function findByActivationToken($token)
    {
        $sql = "SELECT * FROM {$this->table} WHERE activation_token = :token LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $token);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    // NUEVO: Guardar el api_token actual del usuario
    public function setApiToken($userId, $apiToken)
    {
        $sql = "UPDATE {$this->table} SET api_token = :token WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':token', $apiToken);
        $stmt->bindParam(':id', $userId);
        return $stmt->execute();
    }
    
    // Obtener todos los perfiles (usuarios)
    public function getAllProfiles()
    {
        $sql = "SELECT id, username, email, activated FROM {$this->table} ORDER BY username ASC";
        $stmt = $this->conn->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: UserConfigurations.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class UserConfigurations {
    private $conn;
    private $table = 'user_configurations';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo registro en user_configurations y devuelve el nuevo ID
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} (user_id, role, view_type, theme, font_size)
                VALUES (:user_id, :role, :view_type, :theme, :font_size)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':role', $data['role']);
        $stmt->bindParam(':view_type', $data['view_type']);
        $stmt->bindParam(':theme', $data['theme']);
        $stmt->bindParam(':font_size', $data['font_size']);
        if ($stmt->execute()) {
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene una configuraciÃ³n por su ID (sin restricciÃ³n de usuario)
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Obtiene una configuraciÃ³n por user_id (para operaciones propias)
    public function findByUserId($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todas las configuraciones (GET libre)
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza la configuraciÃ³n del registro indicado
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    role = :role,
                    view_type = :view_type,
                    theme = :theme,
                    font_size = :font_size,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':role', $data['role']);
        $stmt->bindParam(':view_type', $data['view_type']);
        $stmt->bindParam(':theme', $data['theme']);
        $stmt->bindParam(':font_size', $data['font_size']);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }

    // Elimina fÃ­sicamente la configuraciÃ³n
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Models
File: UserProfile.php
Content:
<?php
namespace App\Models;

use App\Config\Database;
use PDO;

class UserProfile {
    private $conn;
    private $table = 'user_profile';

    public function __construct() {
        $db = new Database();
        $this->conn = $db->connect();
    }

    // Crea un nuevo registro en user_profile y devuelve el nuevo ID
    public function create(array $data) {
        $sql = "INSERT INTO {$this->table} (user_id, full_name, phone, address, cuit, profile_file_id)
                VALUES (:user_id, :full_name, :phone, :address, :cuit, :profile_file_id)";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $data['user_id'], PDO::PARAM_INT);
        $stmt->bindParam(':full_name', $data['full_name']);
        $stmt->bindParam(':phone', $data['phone']);
        $stmt->bindParam(':address', $data['address']);
        $stmt->bindParam(':cuit', $data['cuit']);
        $profileFileId = $data['profile_file_id'] ?? null;
        $stmt->bindParam(':profile_file_id', $profileFileId);
        if ($stmt->execute()) {
            return $this->conn->lastInsertId();
        }
        return false;
    }

    // Obtiene un perfil por su ID (sin restricciÃ³n de usuario)
    public function findById($id) {
        $sql = "SELECT * FROM {$this->table} WHERE id = :id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Obtiene un perfil por user_id (para operaciones propias)
    public function findByUserId($userId) {
        $sql = "SELECT * FROM {$this->table} WHERE user_id = :user_id LIMIT 1";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    
    // Lista todos los perfiles (GET libre)
    public function listAll() {
        $sql = "SELECT * FROM {$this->table}";
        $stmt = $this->conn->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Actualiza el perfil indicado
    public function update($id, array $data) {
        $sql = "UPDATE {$this->table} SET 
                    full_name = :full_name,
                    phone = :phone,
                    address = :address,
                    cuit = :cuit,
                    profile_file_id = :profile_file_id,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':full_name', $data['full_name']);
        $stmt->bindParam(':phone', $data['phone']);
        $stmt->bindParam(':address', $data['address']);
        $stmt->bindParam(':cuit', $data['cuit']);
        $profileFileId = $data['profile_file_id'] ?? null;
        $stmt->bindParam(':profile_file_id', $profileFileId);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }

    // Elimina fÃ­sicamente el perfil
    public function delete($id) {
        $sql = "DELETE FROM {$this->table} WHERE id = :id";
        $stmt = $this->conn->prepare($sql);
        $stmt->bindParam(':id', $id, PDO::PARAM_INT);
        return $stmt->execute();
    }
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.api/sisa.api\src\Routes
File: api.php
Content:
<?php
use Slim\Factory\AppFactory;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

use App\Middleware\CheckUserBlockedMiddleware;
use App\Middleware\PermissionsMiddleware;
use App\Controllers\PermissionsController;
use App\Controllers\FileController;
use App\Controllers\ProfileController;
use App\Controllers\AuthController;
use App\Controllers\FoldersController;

$authController = new AuthController();

// Rutas pÃºblicas
$app->post('/register', function (Request $request, Response $response, $args) use ($authController) {
    $data = json_decode($request->getBody()->getContents(), true);
    $result = $authController->register($data);
    $response->getBody()->write(json_encode($result));
    return $response->withHeader('Content-Type', 'application/json');
});

$app->post('/login', function (Request $request, Response $response, $args) use ($authController) {
    $data = json_decode($request->getBody()->getContents(), true);
    $result = $authController->login($data);
    $response->getBody()->write(json_encode($result));
    return $response->withHeader('Content-Type', 'application/json');
});

$app->post('/forgot_password', function (Request $request, Response $response, $args) use ($authController) {
    $data = json_decode($request->getBody()->getContents(), true);
    $result = $authController->forgotPassword($data);
    $response->getBody()->write(json_encode($result));
    return $response->withHeader('Content-Type', 'application/json');
});

$app->post('/reset_password', function (Request $request, Response $response, $args) use ($authController) {
    if (!$request->hasHeader('Authorization')) {
        $data = ['error' => 'Falta header Authorization'];
        $response->getBody()->write(json_encode($data));
        return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
    }
    $resetToken = str_replace('Bearer ', '', $request->getHeaderLine('Authorization'));
    $data = json_decode($request->getBody()->getContents(), true);
    $newPassword = $data['new_password'] ?? null;
    $confirmPassword = $data['confirm_password'] ?? null;
    if (!$newPassword || !$confirmPassword) {
        $data = ['error' => 'Faltan new_password y/o confirm_password'];
        $response->getBody()->write(json_encode($data));
        return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
    }
    if ($newPassword !== $confirmPassword) {
        $data = ['error' => 'Las contraseÃ±as no coinciden'];
        $response->getBody()->write(json_encode($data));
        return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
    }
    $result = $authController->resetPassword($resetToken, $newPassword);
    $response->getBody()->write(json_encode($result));
    return $response->withHeader('Content-Type', 'application/json');
});

//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------

// Perfil del usuario (permiso: 'getProfile')
$app->get('/profile', function (Request $request, Response $response, $args) {
    $controller = new ProfileController();
    return $controller->getProfile($request, $response, $args);
})
   // ->add(new PermissionsMiddleware('getProfile'))
    ->add(new CheckUserBlockedMiddleware());

// Subir archivos (permiso: 'uploadFile')
$app->post('/upload', function (Request $request, Response $response, $args) {
    $controller = new FileController();
    return $controller->upload($request, $response, $args);
})
   // ->add(new PermissionsMiddleware('uploadFile'))
    ->add(new CheckUserBlockedMiddleware());

// Descargar archivos (permiso: 'downloadFile')
$app->get('/get_file', function (Request $request, Response $response, $args) {
    $controller = new FileController();
    return $controller->download($request, $response, $args);
})
    //->add(new PermissionsMiddleware('downloadFile'))
    ->add(new CheckUserBlockedMiddleware());

$app->get('/', function (Request $req, Response $res) {
    $res->getBody()->write(json_encode(['message' => 'Bienvenido a la API']));
    return $res->withHeader('Content-Type', 'application/json');
});

//--------------------------------------------------------------------------------------------------------------------
//----------------------------------Super administrador user_id=1-----------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

// Ruta para listar solo los permisos globales (user_id = NULL)
$app->get('/permissions/global', [PermissionsController::class, 'listGlobalPermissions'])
    ->add(new PermissionsMiddleware('listGlobalPermissions'))
    ->add(new CheckUserBlockedMiddleware());

// Ruta para listar permisos filtrados por un usuario especÃ­fico
$app->get('/permissions/user/{user_id}', [PermissionsController::class, 'listPermissionsByUser'])
    ->add(new PermissionsMiddleware('listPermissionsByUser'))
    ->add(new CheckUserBlockedMiddleware());
    
// Ruta para listar todos los permisos
$app->get('/permissions', [PermissionsController::class, 'listPermissions'])
    ->add(new PermissionsMiddleware('listPermissions'))
    ->add(new CheckUserBlockedMiddleware());
    
// Ruta para agregar permisos a los usuarios (protecciÃ³n: permiso 'addPermission')
$app->post('/permissions', [PermissionsController::class, 'addPermission'])
    ->add(new PermissionsMiddleware('addPermission'))
    ->add(new CheckUserBlockedMiddleware());
    
// Ruta para eliminar un permiso (por ID)
$app->delete('/permissions/{id}', [PermissionsController::class, 'deletePermission'])
    ->add(new PermissionsMiddleware('deletePermission'))
    ->add(new CheckUserBlockedMiddleware());
    
// Suponiendo que usas un router tipo Slim o similar:
$app->get('/profiles', [\App\Controllers\ProfilesListController::class, 'listAllProfiles'])
    ->add(new PermissionsMiddleware('listAllProfiles'))
    ->add(new CheckUserBlockedMiddleware());
//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------
// Rutas protegidas con permisos:
//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

// Endpoints para User Profile
$app->get('/user_profile', [\App\Controllers\UserProfileController::class, 'myProfile']) 
    ->add(new CheckUserBlockedMiddleware()); 
$app->get('/user_profile/list', [\App\Controllers\UserProfileController::class, 'listProfiles'])
    ->add(new PermissionsMiddleware('listUserProfiles'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/user_profile/{id}', [\App\Controllers\UserProfileController::class, 'getProfile'])
    ->add(new PermissionsMiddleware('getUserProfile'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/user_profile', [\App\Controllers\UserProfileController::class, 'addProfile'])
    ->add(new PermissionsMiddleware('addUserProfile'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/user_profile', [\App\Controllers\UserProfileController::class, 'updateProfile'])
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/user_profile', [\App\Controllers\UserProfileController::class, 'deleteProfile'])
    ->add(new CheckUserBlockedMiddleware());

// Endpoints para User Configurations
$app->get('/user_configurations', [\App\Controllers\UserConfigurationsController::class, 'myConfigurations'])
    ->add(new CheckUserBlockedMiddleware());
$app->get('/user_configurations/list', [\App\Controllers\UserConfigurationsController::class, 'listConfigurations'])
    ->add(new PermissionsMiddleware('listUserConfigurations'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/user_configurations/{id}', [\App\Controllers\UserConfigurationsController::class, 'getConfiguration'])
    ->add(new PermissionsMiddleware('getUserConfigurations'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/user_configurations', [\App\Controllers\UserConfigurationsController::class, 'addConfiguration'])
    ->add(new PermissionsMiddleware('addUserConfigurations'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/user_configurations', [\App\Controllers\UserConfigurationsController::class, 'updateConfiguration'])
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/user_configurations', [\App\Controllers\UserConfigurationsController::class, 'deleteConfiguration'])
    ->add(new CheckUserBlockedMiddleware());

// Endpoints para Clients
$app->get('/clients/{id}', [\App\Controllers\ClientsController::class, 'getClient'])
    ->add(new PermissionsMiddleware('getClient'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/clients', [\App\Controllers\ClientsController::class, 'addClient'])
    ->add(new PermissionsMiddleware('addClient'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/clients/{id}', [\App\Controllers\ClientsController::class, 'updateClient'])
    ->add(new PermissionsMiddleware('updateClient'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/clients/{id}', [\App\Controllers\ClientsController::class, 'deleteClient'])
    ->add(new PermissionsMiddleware('deleteClient'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/clients', [\App\Controllers\ClientsController::class, 'listClients'])
    ->add(new PermissionsMiddleware('listClients'))
    ->add(new CheckUserBlockedMiddleware());

// Endpoints para Folders
$app->get('/folders', [FoldersController::class, 'listFolders'])
    ->add(new PermissionsMiddleware('listFolders'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/folders/{id}', [FoldersController::class, 'getFolder'])
    ->add(new PermissionsMiddleware('getFolder'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/folders', [FoldersController::class, 'addFolder'])
    ->add(new PermissionsMiddleware('addFolder'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/folders/{id}', [FoldersController::class, 'updateFolder'])
    ->add(new PermissionsMiddleware('updateFolder'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/folders/{id}', [FoldersController::class, 'deleteFolder'])
    ->add(new PermissionsMiddleware('deleteFolder'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/folders/{id}/history', [FoldersController::class, 'listFolderHistory'])
    ->add(new PermissionsMiddleware('listFolderHistory'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/folders/client/{client_id}', [FoldersController::class, 'listFoldersByClient'])
    ->add(new PermissionsMiddleware('listFoldersByClient'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\CashBoxesController;

// Endpoints para Cash Boxes
$app->get('/cash_boxes', [CashBoxesController::class, 'listCashBoxes'])
    ->add(new PermissionsMiddleware('listCashBoxes'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/cash_boxes/{id}', [CashBoxesController::class, 'getCashBox'])
    ->add(new PermissionsMiddleware('getCashBox'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/cash_boxes', [CashBoxesController::class, 'addCashBox'])
    ->add(new PermissionsMiddleware('addCashBox'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/cash_boxes/{id}', [CashBoxesController::class, 'updateCashBox'])
    ->add(new PermissionsMiddleware('updateCashBox'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/cash_boxes/{id}', [CashBoxesController::class, 'deleteCashBox'])
    ->add(new PermissionsMiddleware('deleteCashBox'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/cash_boxes/{id}/history', [CashBoxesController::class, 'listCashBoxHistory'])
    ->add(new PermissionsMiddleware('listCashBoxHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\SalesController;

// Endpoints para Sales
$app->get('/sales', [SalesController::class, 'listSales'])
    ->add(new PermissionsMiddleware('listSales'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/sales/{id}', [SalesController::class, 'getSale'])
    ->add(new PermissionsMiddleware('getSale'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/sales', [SalesController::class, 'addSale'])
    ->add(new PermissionsMiddleware('addSale'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/sales/{id}', [SalesController::class, 'updateSale'])
    ->add(new PermissionsMiddleware('updateSale'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/sales/{id}', [SalesController::class, 'deleteSale'])
    ->add(new PermissionsMiddleware('deleteSale'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/sales/{id}/history', [SalesController::class, 'listSaleHistory'])
    ->add(new PermissionsMiddleware('listSaleHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\ProductsServicesController;

$app->get('/products_services', [ProductsServicesController::class, 'listProductsServices'])
    ->add(new PermissionsMiddleware('listProductsServices'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/products_services/{id}', [ProductsServicesController::class, 'getProductService'])
    ->add(new PermissionsMiddleware('getProductService'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/products_services', [ProductsServicesController::class, 'addProductService'])
    ->add(new PermissionsMiddleware('addProductService'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/products_services/{id}', [ProductsServicesController::class, 'updateProductService'])
    ->add(new PermissionsMiddleware('updateProductService'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/products_services/{id}', [ProductsServicesController::class, 'deleteProductService'])
    ->add(new PermissionsMiddleware('deleteProductService'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/products_services/{id}/history', [ProductsServicesController::class, 'listProductServiceHistory'])
    ->add(new PermissionsMiddleware('listProductServiceHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\JobsController;

$app->get('/jobs', [JobsController::class, 'listJobs'])
    ->add(new PermissionsMiddleware('listJobs'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/jobs/{id}', [JobsController::class, 'getJob'])
    ->add(new PermissionsMiddleware('getJob'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/jobs', [JobsController::class, 'addJob'])
    ->add(new PermissionsMiddleware('addJob'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/jobs/{id}', [JobsController::class, 'updateJob'])
    ->add(new PermissionsMiddleware('updateJob'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/jobs/{id}', [JobsController::class, 'deleteJob'])
    ->add(new PermissionsMiddleware('deleteJob'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/jobs/{id}/history', [JobsController::class, 'listJobHistory'])
    ->add(new PermissionsMiddleware('listJobHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\ExpensesController;

$app->get('/expenses', [ExpensesController::class, 'listExpenses'])
    ->add(new PermissionsMiddleware('listExpenses'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/expenses/{id}', [ExpensesController::class, 'getExpense'])
    ->add(new PermissionsMiddleware('getExpense'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/expenses', [ExpensesController::class, 'addExpense'])
    ->add(new PermissionsMiddleware('addExpense'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/expenses/{id}', [ExpensesController::class, 'updateExpense'])
    ->add(new PermissionsMiddleware('updateExpense'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/expenses/{id}', [ExpensesController::class, 'deleteExpense'])
    ->add(new PermissionsMiddleware('deleteExpense'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/expenses/{id}/history', [ExpensesController::class, 'listExpenseHistory'])
    ->add(new PermissionsMiddleware('listExpenseHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\AppointmentsController;

$app->get('/appointments', [AppointmentsController::class, 'listAppointments'])
    ->add(new PermissionsMiddleware('listAppointments'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/appointments/{id}', [AppointmentsController::class, 'getAppointment'])
    ->add(new PermissionsMiddleware('getAppointment'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/appointments', [AppointmentsController::class, 'addAppointment'])
    ->add(new PermissionsMiddleware('addAppointment'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/appointments/{id}', [AppointmentsController::class, 'updateAppointment'])
    ->add(new PermissionsMiddleware('updateAppointment'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/appointments/{id}', [AppointmentsController::class, 'deleteAppointment'])
    ->add(new PermissionsMiddleware('deleteAppointment'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/appointments/{id}/history', [AppointmentsController::class, 'listAppointmentHistory'])
    ->add(new PermissionsMiddleware('listAppointmentHistory'))
    ->add(new CheckUserBlockedMiddleware());

use App\Controllers\AccountingClosingsController;

$app->get('/accounting_closings', [AccountingClosingsController::class, 'listClosings'])
    ->add(new PermissionsMiddleware('listClosings'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/accounting_closings/{id}', [AccountingClosingsController::class, 'getClosing'])
    ->add(new PermissionsMiddleware('getClosing'))
    ->add(new CheckUserBlockedMiddleware());
$app->post('/accounting_closings', [AccountingClosingsController::class, 'addClosing'])
    ->add(new PermissionsMiddleware('addClosing'))
    ->add(new CheckUserBlockedMiddleware());
$app->put('/accounting_closings/{id}', [AccountingClosingsController::class, 'updateClosing'])
    ->add(new PermissionsMiddleware('updateClosing'))
    ->add(new CheckUserBlockedMiddleware());
$app->delete('/accounting_closings/{id}', [AccountingClosingsController::class, 'deleteClosing'])
    ->add(new PermissionsMiddleware('deleteClosing'))
    ->add(new CheckUserBlockedMiddleware());
$app->get('/accounting_closings/{id}/history', [AccountingClosingsController::class, 'listClosingHistory'])
    ->add(new PermissionsMiddleware('listClosingHistory'))
    ->add(new CheckUserBlockedMiddleware());

// Ruta por defecto para manejar "Not found"
$app->any('/{routes:.+}', function (Request $request, Response $response) {
    $data = ['error' => 'Not found'];
    $response->getBody()->write(json_encode($data));
    return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
});

---
